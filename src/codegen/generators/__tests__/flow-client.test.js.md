# Snapshot report for `dist/codegen/flow-client.test.js`

The actual snapshot is saved in `flow-client.test.js.snap`.

Generated by [AVA](https://ava.li).

## flow generator

> Snapshot 1

    `/**␊
     * @flow␊
     */␊
    ␊
    // Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.␊
    // Please don't change this file manually but run `prisma generate` to update it.␊
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/␊
    ␊
    import type { DocumentNode } from "graphql";␊
    import type { BasePrismaOptions as BPOType } from "prisma-client-lib";␊
    import { makePrismaClientClass, Model } from "prisma-client-lib";␊
    import { typeDefs } from "./prisma-schema";␊
    ␊
    type NodePromise = Promise<Node>;␊
    ␊
    export type AtLeastOne<T> = $Shape<T>;␊
    ␊
    export interface Exists {␊
      post(where?: PostWhereInput): Promise<boolean>;␊
      user(where?: UserWhereInput): Promise<boolean>;␊
    }␊
    ␊
    export interface Node {}␊
    ␊
    export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;␊
    ␊
    export interface Fragmentable {␊
      $fragment<T>(fragment: string | DocumentNode): Promise<T>;␊
    }␊
    ␊
    export interface PrismaInterface {␊
      $exists: Exists;␊
      $graphql: <T: any>(␊
        query: string,␊
        variables?: { [key: string]: any }␊
      ) => Promise<T>;␊
    ␊
      /**␊
       * Queries␊
       */␊
    ␊
      posts: (args?: {␊
        where?: PostWhereInput,␊
        orderBy?: PostOrderByInput,␊
        skip?: Int,␊
        after?: String,␊
        before?: String,␊
        first?: Int,␊
        last?: Int␊
      }) => FragmentableArray<Post>;␊
      users: (args?: {␊
        where?: UserWhereInput,␊
        orderBy?: UserOrderByInput,␊
        skip?: Int,␊
        after?: String,␊
        before?: String,␊
        first?: Int,␊
        last?: Int␊
      }) => FragmentableArray<User>;␊
      post: (where: PostWhereUniqueInput) => PostPromise;␊
      user: (where: UserWhereUniqueInput) => UserPromise;␊
      postsConnection: (args?: {␊
        where?: PostWhereInput,␊
        orderBy?: PostOrderByInput,␊
        skip?: Int,␊
        after?: String,␊
        before?: String,␊
        first?: Int,␊
        last?: Int␊
      }) => PostConnectionPromise;␊
      usersConnection: (args?: {␊
        where?: UserWhereInput,␊
        orderBy?: UserOrderByInput,␊
        skip?: Int,␊
        after?: String,␊
        before?: String,␊
        first?: Int,␊
        last?: Int␊
      }) => UserConnectionPromise;␊
      node: (args: { id: ID_Output }) => Node;␊
    ␊
      /**␊
       * Mutations␊
       */␊
    ␊
      createPost: (data: PostCreateInput) => PostPromise;␊
      createUser: (data: UserCreateInput) => UserPromise;␊
      updatePost: (args: {␊
        data: PostUpdateInput,␊
        where: PostWhereUniqueInput␊
      }) => PostPromise;␊
      updateUser: (args: {␊
        data: UserUpdateInput,␊
        where: UserWhereUniqueInput␊
      }) => UserPromise;␊
      deletePost: (where: PostWhereUniqueInput) => PostPromise;␊
      deleteUser: (where: UserWhereUniqueInput) => UserPromise;␊
      upsertPost: (args: {␊
        where: PostWhereUniqueInput,␊
        create: PostCreateInput,␊
        update: PostUpdateInput␊
      }) => PostPromise;␊
      upsertUser: (args: {␊
        where: UserWhereUniqueInput,␊
        create: UserCreateInput,␊
        update: UserUpdateInput␊
      }) => UserPromise;␊
      updateManyPosts: (args: {␊
        data: PostUpdateInput,␊
        where: PostWhereInput␊
      }) => BatchPayloadPromise;␊
      updateManyUsers: (args: {␊
        data: UserUpdateInput,␊
        where: UserWhereInput␊
      }) => BatchPayloadPromise;␊
      deleteManyPosts: (where: PostWhereInput) => BatchPayloadPromise;␊
      deleteManyUsers: (where: UserWhereInput) => BatchPayloadPromise;␊
    ␊
      /**␊
       * Subscriptions␊
       */␊
    ␊
      $subscribe: Subscription;␊
    }␊
    ␊
    export interface Subscription {␊
      post: (␊
        where?: PostSubscriptionWhereInput␊
      ) => PostSubscriptionPayloadSubscription;␊
      user: (␊
        where?: UserSubscriptionWhereInput␊
      ) => UserSubscriptionPayloadSubscription;␊
    }␊
    ␊
    export type ClientConstructor<T> = (options?: BPOType) => T;␊
    ␊
    /**␊
     * Types␊
     */␊
    ␊
    export type PostOrderByInput =␊
      | "id_ASC"␊
      | "id_DESC"␊
      | "createdAt_ASC"␊
      | "createdAt_DESC"␊
      | "updatedAt_ASC"␊
      | "updatedAt_DESC"␊
      | "isPublished_ASC"␊
      | "isPublished_DESC"␊
      | "title_ASC"␊
      | "title_DESC"␊
      | "text_ASC"␊
      | "text_DESC";␊
    ␊
    export type UserOrderByInput =␊
      | "id_ASC"␊
      | "id_DESC"␊
      | "email_ASC"␊
      | "email_DESC"␊
      | "password_ASC"␊
      | "password_DESC"␊
      | "name_ASC"␊
      | "name_DESC"␊
      | "updatedAt_ASC"␊
      | "updatedAt_DESC"␊
      | "createdAt_ASC"␊
      | "createdAt_DESC";␊
    ␊
    export type MutationType = "CREATED" | "UPDATED" | "DELETED";␊
    ␊
    export type UserCreateOneWithoutPostsInput = {␊
      create?: UserCreateWithoutPostsInput,␊
      connect?: UserWhereUniqueInput␊
    };␊
    ␊
    export type PostWhereInput = {␊
      AND?: PostWhereInput[],␊
      OR?: PostWhereInput[],␊
      id?: ID_Input,␊
      id_not?: ID_Input,␊
      id_in?: ID_Input[],␊
      id_not_in?: ID_Input[],␊
      id_lt?: ID_Input,␊
      id_lte?: ID_Input,␊
      id_gt?: ID_Input,␊
      id_gte?: ID_Input,␊
      id_contains?: ID_Input,␊
      id_not_contains?: ID_Input,␊
      id_starts_with?: ID_Input,␊
      id_not_starts_with?: ID_Input,␊
      id_ends_with?: ID_Input,␊
      id_not_ends_with?: ID_Input,␊
      createdAt?: DateTimeInput,␊
      createdAt_not?: DateTimeInput,␊
      createdAt_in?: DateTimeInput[],␊
      createdAt_not_in?: DateTimeInput[],␊
      createdAt_lt?: DateTimeInput,␊
      createdAt_lte?: DateTimeInput,␊
      createdAt_gt?: DateTimeInput,␊
      createdAt_gte?: DateTimeInput,␊
      updatedAt?: DateTimeInput,␊
      updatedAt_not?: DateTimeInput,␊
      updatedAt_in?: DateTimeInput[],␊
      updatedAt_not_in?: DateTimeInput[],␊
      updatedAt_lt?: DateTimeInput,␊
      updatedAt_lte?: DateTimeInput,␊
      updatedAt_gt?: DateTimeInput,␊
      updatedAt_gte?: DateTimeInput,␊
      isPublished?: Boolean,␊
      isPublished_not?: Boolean,␊
      title?: String,␊
      title_not?: String,␊
      title_in?: String[],␊
      title_not_in?: String[],␊
      title_lt?: String,␊
      title_lte?: String,␊
      title_gt?: String,␊
      title_gte?: String,␊
      title_contains?: String,␊
      title_not_contains?: String,␊
      title_starts_with?: String,␊
      title_not_starts_with?: String,␊
      title_ends_with?: String,␊
      title_not_ends_with?: String,␊
      text?: String,␊
      text_not?: String,␊
      text_in?: String[],␊
      text_not_in?: String[],␊
      text_lt?: String,␊
      text_lte?: String,␊
      text_gt?: String,␊
      text_gte?: String,␊
      text_contains?: String,␊
      text_not_contains?: String,␊
      text_starts_with?: String,␊
      text_not_starts_with?: String,␊
      text_ends_with?: String,␊
      text_not_ends_with?: String,␊
      author?: UserWhereInput␊
    };␊
    ␊
    export type PostCreateManyWithoutAuthorInput = {␊
      create?: PostCreateWithoutAuthorInput[],␊
      connect?: PostWhereUniqueInput[]␊
    };␊
    ␊
    export type UserWhereInput = {␊
      AND?: UserWhereInput[],␊
      OR?: UserWhereInput[],␊
      id?: ID_Input,␊
      id_not?: ID_Input,␊
      id_in?: ID_Input[],␊
      id_not_in?: ID_Input[],␊
      id_lt?: ID_Input,␊
      id_lte?: ID_Input,␊
      id_gt?: ID_Input,␊
      id_gte?: ID_Input,␊
      id_contains?: ID_Input,␊
      id_not_contains?: ID_Input,␊
      id_starts_with?: ID_Input,␊
      id_not_starts_with?: ID_Input,␊
      id_ends_with?: ID_Input,␊
      id_not_ends_with?: ID_Input,␊
      email?: String,␊
      email_not?: String,␊
      email_in?: String[],␊
      email_not_in?: String[],␊
      email_lt?: String,␊
      email_lte?: String,␊
      email_gt?: String,␊
      email_gte?: String,␊
      email_contains?: String,␊
      email_not_contains?: String,␊
      email_starts_with?: String,␊
      email_not_starts_with?: String,␊
      email_ends_with?: String,␊
      email_not_ends_with?: String,␊
      password?: String,␊
      password_not?: String,␊
      password_in?: String[],␊
      password_not_in?: String[],␊
      password_lt?: String,␊
      password_lte?: String,␊
      password_gt?: String,␊
      password_gte?: String,␊
      password_contains?: String,␊
      password_not_contains?: String,␊
      password_starts_with?: String,␊
      password_not_starts_with?: String,␊
      password_ends_with?: String,␊
      password_not_ends_with?: String,␊
      name?: String,␊
      name_not?: String,␊
      name_in?: String[],␊
      name_not_in?: String[],␊
      name_lt?: String,␊
      name_lte?: String,␊
      name_gt?: String,␊
      name_gte?: String,␊
      name_contains?: String,␊
      name_not_contains?: String,␊
      name_starts_with?: String,␊
      name_not_starts_with?: String,␊
      name_ends_with?: String,␊
      name_not_ends_with?: String,␊
      posts_every?: PostWhereInput,␊
      posts_some?: PostWhereInput,␊
      posts_none?: PostWhereInput␊
    };␊
    ␊
    export type PostUpdateManyWithoutAuthorInput = {␊
      create?: PostCreateWithoutAuthorInput[],␊
      connect?: PostWhereUniqueInput[],␊
      disconnect?: PostWhereUniqueInput[],␊
      delete?: PostWhereUniqueInput[],␊
      update?: PostUpdateWithWhereUniqueWithoutAuthorInput[],␊
      upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput[]␊
    };␊
    ␊
    export type PostUpdateInput = {␊
      isPublished?: Boolean,␊
      title?: String,␊
      text?: String,␊
      author?: UserUpdateOneWithoutPostsInput␊
    };␊
    ␊
    export type UserUpdateInput = {␊
      email?: String,␊
      password?: String,␊
      name?: String,␊
      posts?: PostUpdateManyWithoutAuthorInput␊
    };␊
    ␊
    export type PostCreateWithoutAuthorInput = {␊
      isPublished?: Boolean,␊
      title: String,␊
      text: String␊
    };␊
    ␊
    export type UserUpsertWithoutPostsInput = {␊
      update: UserUpdateWithoutPostsDataInput,␊
      create: UserCreateWithoutPostsInput␊
    };␊
    ␊
    export type UserSubscriptionWhereInput = {␊
      AND?: UserSubscriptionWhereInput[],␊
      OR?: UserSubscriptionWhereInput[],␊
      mutation_in?: MutationType[],␊
      updatedFields_contains?: String,␊
      updatedFields_contains_every?: String[],␊
      updatedFields_contains_some?: String[],␊
      node?: UserWhereInput␊
    };␊
    ␊
    export type UserUpdateWithoutPostsDataInput = {␊
      email?: String,␊
      password?: String,␊
      name?: String␊
    };␊
    ␊
    export type PostWhereUniqueInput = {␊
      id?: ID_Input␊
    };␊
    ␊
    export type PostUpsertWithWhereUniqueWithoutAuthorInput = {␊
      where: PostWhereUniqueInput,␊
      update: PostUpdateWithoutAuthorDataInput,␊
      create: PostCreateWithoutAuthorInput␊
    };␊
    ␊
    export type UserCreateInput = {␊
      email: String,␊
      password: String,␊
      name: String,␊
      posts?: PostCreateManyWithoutAuthorInput␊
    };␊
    ␊
    export type UserCreateWithoutPostsInput = {␊
      email: String,␊
      password: String,␊
      name: String␊
    };␊
    ␊
    export type UserUpdateOneWithoutPostsInput = {␊
      create?: UserCreateWithoutPostsInput,␊
      connect?: UserWhereUniqueInput,␊
      delete?: Boolean,␊
      update?: UserUpdateWithoutPostsDataInput,␊
      upsert?: UserUpsertWithoutPostsInput␊
    };␊
    ␊
    export type PostCreateInput = {␊
      isPublished?: Boolean,␊
      title: String,␊
      text: String,␊
      author: UserCreateOneWithoutPostsInput␊
    };␊
    ␊
    export type PostUpdateWithoutAuthorDataInput = {␊
      isPublished?: Boolean,␊
      title?: String,␊
      text?: String␊
    };␊
    ␊
    export type UserWhereUniqueInput = {␊
      id?: ID_Input,␊
      email?: String␊
    };␊
    ␊
    export type PostSubscriptionWhereInput = {␊
      AND?: PostSubscriptionWhereInput[],␊
      OR?: PostSubscriptionWhereInput[],␊
      mutation_in?: MutationType[],␊
      updatedFields_contains?: String,␊
      updatedFields_contains_every?: String[],␊
      updatedFields_contains_some?: String[],␊
      node?: PostWhereInput␊
    };␊
    ␊
    export type PostUpdateWithWhereUniqueWithoutAuthorInput = {␊
      where: PostWhereUniqueInput,␊
      data: PostUpdateWithoutAuthorDataInput␊
    };␊
    ␊
    /*␊
     * An object with an ID␊
    ␊
     */␊
    export interface NodeNode {␊
      id: ID_Output;␊
    }␊
    ␊
    export interface UserPreviousValues {␊
      id: ID_Output;␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserPreviousValuesPromise␊
      extends Promise<UserPreviousValues>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
    }␊
    ␊
    export interface UserPreviousValuesSubscription␊
      extends Promise<AsyncIterator<UserPreviousValues>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      email: () => Promise<AsyncIterator<String>>;␊
      password: () => Promise<AsyncIterator<String>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface PostConnection {␊
      pageInfo: PageInfo;␊
      edges: PostEdge[];␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface PostConnectionPromise␊
      extends Promise<PostConnection>,␊
        Fragmentable {␊
      pageInfo: <T: PageInfoPromise>() => T;␊
      edges: <T: FragmentableArray<PostEdge>>() => T;␊
      aggregate: <T: AggregatePostPromise>() => T;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface PostConnectionSubscription␊
      extends Promise<AsyncIterator<PostConnection>>,␊
        Fragmentable {␊
      pageInfo: <T: PageInfoSubscription>() => T;␊
      edges: <T: Promise<AsyncIterator<PostEdgeSubscription>>>() => T;␊
      aggregate: <T: AggregatePostSubscription>() => T;␊
    }␊
    ␊
    export interface Post extends Node {␊
      id: ID_Output;␊
      createdAt: DateTimeOutput;␊
      updatedAt: DateTimeOutput;␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostPromise extends Promise<Post>, Fragmentable, Node {␊
      id: () => Promise<ID_Output>;␊
      createdAt: () => Promise<DateTimeOutput>;␊
      updatedAt: () => Promise<DateTimeOutput>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
      author: <T: UserPromise>() => T;␊
    }␊
    ␊
    export interface PostSubscription␊
      extends Promise<AsyncIterator<Post>>,␊
        Fragmentable,␊
        Node {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      isPublished: () => Promise<AsyncIterator<Boolean>>;␊
      title: () => Promise<AsyncIterator<String>>;␊
      text: () => Promise<AsyncIterator<String>>;␊
      author: <T: UserSubscription>() => T;␊
    }␊
    ␊
    /*␊
     * Information about pagination in a connection.␊
    ␊
     */␊
    export interface PageInfo {␊
      hasNextPage: Boolean;␊
      hasPreviousPage: Boolean;␊
      startCursor?: String;␊
      endCursor?: String;␊
    }␊
    ␊
    /*␊
     * Information about pagination in a connection.␊
    ␊
     */␊
    export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {␊
      hasNextPage: () => Promise<Boolean>;␊
      hasPreviousPage: () => Promise<Boolean>;␊
      startCursor: () => Promise<String>;␊
      endCursor: () => Promise<String>;␊
    }␊
    ␊
    /*␊
     * Information about pagination in a connection.␊
    ␊
     */␊
    export interface PageInfoSubscription␊
      extends Promise<AsyncIterator<PageInfo>>,␊
        Fragmentable {␊
      hasNextPage: () => Promise<AsyncIterator<Boolean>>;␊
      hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;␊
      startCursor: () => Promise<AsyncIterator<String>>;␊
      endCursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface PostSubscriptionPayload {␊
      mutation: MutationType;␊
      node: Post;␊
      updatedFields: String[];␊
      previousValues: PostPreviousValues;␊
    }␊
    ␊
    export interface PostSubscriptionPayloadPromise␊
      extends Promise<PostSubscriptionPayload>,␊
        Fragmentable {␊
      mutation: () => Promise<MutationType>;␊
      node: <T: PostPromise>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T: PostPreviousValuesPromise>() => T;␊
    }␊
    ␊
    export interface PostSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<PostSubscriptionPayload>>,␊
        Fragmentable {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T: PostSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T: PostPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    export interface BatchPayload {␊
      count: Long;␊
    }␊
    ␊
    export interface BatchPayloadPromise␊
      extends Promise<BatchPayload>,␊
        Fragmentable {␊
      count: () => Promise<Long>;␊
    }␊
    ␊
    export interface BatchPayloadSubscription␊
      extends Promise<AsyncIterator<BatchPayload>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Long>>;␊
    }␊
    ␊
    export interface PostPreviousValues {␊
      id: ID_Output;␊
      createdAt: DateTimeOutput;␊
      updatedAt: DateTimeOutput;␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostPreviousValuesPromise␊
      extends Promise<PostPreviousValues>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      createdAt: () => Promise<DateTimeOutput>;␊
      updatedAt: () => Promise<DateTimeOutput>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
    }␊
    ␊
    export interface PostPreviousValuesSubscription␊
      extends Promise<AsyncIterator<PostPreviousValues>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      isPublished: () => Promise<AsyncIterator<Boolean>>;␊
      title: () => Promise<AsyncIterator<String>>;␊
      text: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface User extends Node {␊
      id: ID_Output;␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserPromise extends Promise<User>, Fragmentable, Node {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
      posts: <T: FragmentableArray<Post>>(args?: {␊
        where?: PostWhereInput,␊
        orderBy?: PostOrderByInput,␊
        skip?: Int,␊
        after?: String,␊
        before?: String,␊
        first?: Int,␊
        last?: Int␊
      }) => T;␊
    }␊
    ␊
    export interface UserSubscription␊
      extends Promise<AsyncIterator<User>>,␊
        Fragmentable,␊
        Node {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      email: () => Promise<AsyncIterator<String>>;␊
      password: () => Promise<AsyncIterator<String>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
      posts: <T: Promise<AsyncIterator<PostSubscription>>>(args?: {␊
        where?: PostWhereInput,␊
        orderBy?: PostOrderByInput,␊
        skip?: Int,␊
        after?: String,␊
        before?: String,␊
        first?: Int,␊
        last?: Int␊
      }) => T;␊
    }␊
    ␊
    export interface AggregateUser {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregateUserPromise␊
      extends Promise<AggregateUser>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregateUserSubscription␊
      extends Promise<AsyncIterator<AggregateUser>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface UserSubscriptionPayload {␊
      mutation: MutationType;␊
      node: User;␊
      updatedFields: String[];␊
      previousValues: UserPreviousValues;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadPromise␊
      extends Promise<UserSubscriptionPayload>,␊
        Fragmentable {␊
      mutation: () => Promise<MutationType>;␊
      node: <T: UserPromise>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T: UserPreviousValuesPromise>() => T;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<UserSubscriptionPayload>>,␊
        Fragmentable {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T: UserSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T: UserPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface UserEdge {␊
      node: User;␊
      cursor: String;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {␊
      node: <T: UserPromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface UserEdgeSubscription␊
      extends Promise<AsyncIterator<UserEdge>>,␊
        Fragmentable {␊
      node: <T: UserSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface PostEdge {␊
      node: Post;␊
      cursor: String;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {␊
      node: <T: PostPromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface PostEdgeSubscription␊
      extends Promise<AsyncIterator<PostEdge>>,␊
        Fragmentable {␊
      node: <T: PostSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface AggregatePost {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregatePostPromise␊
      extends Promise<AggregatePost>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregatePostSubscription␊
      extends Promise<AsyncIterator<AggregatePost>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface UserConnection {␊
      pageInfo: PageInfo;␊
      edges: UserEdge[];␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface UserConnectionPromise␊
      extends Promise<UserConnection>,␊
        Fragmentable {␊
      pageInfo: <T: PageInfoPromise>() => T;␊
      edges: <T: FragmentableArray<UserEdge>>() => T;␊
      aggregate: <T: AggregateUserPromise>() => T;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface UserConnectionSubscription␊
      extends Promise<AsyncIterator<UserConnection>>,␊
        Fragmentable {␊
      pageInfo: <T: PageInfoSubscription>() => T;␊
      edges: <T: Promise<AsyncIterator<UserEdgeSubscription>>>() => T;␊
      aggregate: <T: AggregateUserSubscription>() => T;␊
    }␊
    ␊
    /*␊
    The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. ␊
    */␊
    export type Int = number;␊
    ␊
    /*␊
    The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.␊
    */␊
    export type ID_Input = string | number;␊
    export type ID_Output = string;␊
    ␊
    /*␊
    The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.␊
    */␊
    export type String = string;␊
    ␊
    /*␊
    The `Long` scalar type represents non-fractional signed whole numeric values.␊
    Long can represent values between -(2^63) and 2^63 - 1.␊
    */␊
    export type Long = string;␊
    ␊
    /*␊
    The `Boolean` scalar type represents `true` or `false`.␊
    */␊
    export type Boolean = boolean;␊
    ␊
    /*␊
    DateTime scalar input type, allowing Date␊
    */␊
    export type DateTimeInput = Date | string;␊
    ␊
    /*␊
    DateTime scalar output type, which is always a string␊
    */␊
    export type DateTimeOutput = string;␊
    ␊
    /**␊
     * Model Metadata␊
     */␊
    ␊
    export const models: Model[] = [];␊
    ␊
    /**␊
     * Type Defs␊
     */␊
    ␊
    export const Prisma: ClientConstructor<PrismaInterface> = makePrismaClientClass(␊
      { typeDefs, models }␊
    );␊
    ␊
    export const prisma = new Prisma();␊
    `

## flow generator - print schema

> Snapshot 1

    `// @flow␊
    export const typeDefs = /* GraphQL */ `type AggregatePost {␊
      count: Int!␊
    }␊
    ␊
    type AggregateUser {␊
      count: Int!␊
    }␊
    ␊
    type BatchPayload {␊
      """The number of nodes that have been affected by the Batch operation."""␊
      count: Long!␊
    }␊
    ␊
    scalar DateTime␊
    ␊
    """␊
    The \\`Long\\` scalar type represents non-fractional signed whole numeric values.␊
    Long can represent values between -(2^63) and 2^63 - 1.␊
    """␊
    scalar Long␊
    ␊
    type Mutation {␊
      createPost(data: PostCreateInput!): Post!␊
      createUser(data: UserCreateInput!): User!␊
      updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post␊
      updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User␊
      deletePost(where: PostWhereUniqueInput!): Post␊
      deleteUser(where: UserWhereUniqueInput!): User␊
      upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!␊
      upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!␊
      updateManyPosts(data: PostUpdateInput!, where: PostWhereInput!): BatchPayload!␊
      updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload!␊
      deleteManyPosts(where: PostWhereInput!): BatchPayload!␊
      deleteManyUsers(where: UserWhereInput!): BatchPayload!␊
    }␊
    ␊
    enum MutationType {␊
      CREATED␊
      UPDATED␊
      DELETED␊
    }␊
    ␊
    """An object with an ID"""␊
    interface Node {␊
      """The id of the object."""␊
      id: ID!␊
    }␊
    ␊
    """Information about pagination in a connection."""␊
    type PageInfo {␊
      """When paginating forwards, are there more items?"""␊
      hasNextPage: Boolean!␊
    ␊
      """When paginating backwards, are there more items?"""␊
      hasPreviousPage: Boolean!␊
    ␊
      """When paginating backwards, the cursor to continue."""␊
      startCursor: String␊
    ␊
      """When paginating forwards, the cursor to continue."""␊
      endCursor: String␊
    }␊
    ␊
    type Post implements Node {␊
      id: ID!␊
      createdAt: DateTime!␊
      updatedAt: DateTime!␊
      isPublished: Boolean!␊
      title: String!␊
      text: String!␊
      author: User!␊
    }␊
    ␊
    """A connection to a list of items."""␊
    type PostConnection {␊
      """Information to aid in pagination."""␊
      pageInfo: PageInfo!␊
    ␊
      """A list of edges."""␊
      edges: [PostEdge]!␊
      aggregate: AggregatePost!␊
    }␊
    ␊
    input PostCreateInput {␊
      isPublished: Boolean␊
      title: String!␊
      text: String!␊
      author: UserCreateOneWithoutPostsInput!␊
    }␊
    ␊
    input PostCreateManyWithoutAuthorInput {␊
      create: [PostCreateWithoutAuthorInput!]␊
      connect: [PostWhereUniqueInput!]␊
    }␊
    ␊
    input PostCreateWithoutAuthorInput {␊
      isPublished: Boolean␊
      title: String!␊
      text: String!␊
    }␊
    ␊
    """An edge in a connection."""␊
    type PostEdge {␊
      """The item at the end of the edge."""␊
      node: Post!␊
    ␊
      """A cursor for use in pagination."""␊
      cursor: String!␊
    }␊
    ␊
    enum PostOrderByInput {␊
      id_ASC␊
      id_DESC␊
      createdAt_ASC␊
      createdAt_DESC␊
      updatedAt_ASC␊
      updatedAt_DESC␊
      isPublished_ASC␊
      isPublished_DESC␊
      title_ASC␊
      title_DESC␊
      text_ASC␊
      text_DESC␊
    }␊
    ␊
    type PostPreviousValues {␊
      id: ID!␊
      createdAt: DateTime!␊
      updatedAt: DateTime!␊
      isPublished: Boolean!␊
      title: String!␊
      text: String!␊
    }␊
    ␊
    type PostSubscriptionPayload {␊
      mutation: MutationType!␊
      node: Post␊
      updatedFields: [String!]␊
      previousValues: PostPreviousValues␊
    }␊
    ␊
    input PostSubscriptionWhereInput {␊
      """Logical AND on all given filters."""␊
      AND: [PostSubscriptionWhereInput!]␊
    ␊
      """Logical OR on all given filters."""␊
      OR: [PostSubscriptionWhereInput!]␊
    ␊
      """␊
      The subscription event gets dispatched when it's listed in mutation_in␊
      """␊
      mutation_in: [MutationType!]␊
    ␊
      """␊
      The subscription event gets only dispatched when one of the updated fields names is included in this list␊
      """␊
      updatedFields_contains: String␊
    ␊
      """␊
      The subscription event gets only dispatched when all of the field names included in this list have been updated␊
      """␊
      updatedFields_contains_every: [String!]␊
    ␊
      """␊
      The subscription event gets only dispatched when some of the field names included in this list have been updated␊
      """␊
      updatedFields_contains_some: [String!]␊
      node: PostWhereInput␊
    }␊
    ␊
    input PostUpdateInput {␊
      isPublished: Boolean␊
      title: String␊
      text: String␊
      author: UserUpdateOneWithoutPostsInput␊
    }␊
    ␊
    input PostUpdateManyWithoutAuthorInput {␊
      create: [PostCreateWithoutAuthorInput!]␊
      connect: [PostWhereUniqueInput!]␊
      disconnect: [PostWhereUniqueInput!]␊
      delete: [PostWhereUniqueInput!]␊
      update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]␊
      upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]␊
    }␊
    ␊
    input PostUpdateWithoutAuthorDataInput {␊
      isPublished: Boolean␊
      title: String␊
      text: String␊
    }␊
    ␊
    input PostUpdateWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput!␊
      data: PostUpdateWithoutAuthorDataInput!␊
    }␊
    ␊
    input PostUpsertWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput!␊
      update: PostUpdateWithoutAuthorDataInput!␊
      create: PostCreateWithoutAuthorInput!␊
    }␊
    ␊
    input PostWhereInput {␊
      """Logical AND on all given filters."""␊
      AND: [PostWhereInput!]␊
    ␊
      """Logical OR on all given filters."""␊
      OR: [PostWhereInput!]␊
      id: ID␊
    ␊
      """All values that are not equal to given value."""␊
      id_not: ID␊
    ␊
      """All values that are contained in given list."""␊
      id_in: [ID!]␊
    ␊
      """All values that are not contained in given list."""␊
      id_not_in: [ID!]␊
    ␊
      """All values less than the given value."""␊
      id_lt: ID␊
    ␊
      """All values less than or equal the given value."""␊
      id_lte: ID␊
    ␊
      """All values greater than the given value."""␊
      id_gt: ID␊
    ␊
      """All values greater than or equal the given value."""␊
      id_gte: ID␊
    ␊
      """All values containing the given string."""␊
      id_contains: ID␊
    ␊
      """All values not containing the given string."""␊
      id_not_contains: ID␊
    ␊
      """All values starting with the given string."""␊
      id_starts_with: ID␊
    ␊
      """All values not starting with the given string."""␊
      id_not_starts_with: ID␊
    ␊
      """All values ending with the given string."""␊
      id_ends_with: ID␊
    ␊
      """All values not ending with the given string."""␊
      id_not_ends_with: ID␊
      createdAt: DateTime␊
    ␊
      """All values that are not equal to given value."""␊
      createdAt_not: DateTime␊
    ␊
      """All values that are contained in given list."""␊
      createdAt_in: [DateTime!]␊
    ␊
      """All values that are not contained in given list."""␊
      createdAt_not_in: [DateTime!]␊
    ␊
      """All values less than the given value."""␊
      createdAt_lt: DateTime␊
    ␊
      """All values less than or equal the given value."""␊
      createdAt_lte: DateTime␊
    ␊
      """All values greater than the given value."""␊
      createdAt_gt: DateTime␊
    ␊
      """All values greater than or equal the given value."""␊
      createdAt_gte: DateTime␊
      updatedAt: DateTime␊
    ␊
      """All values that are not equal to given value."""␊
      updatedAt_not: DateTime␊
    ␊
      """All values that are contained in given list."""␊
      updatedAt_in: [DateTime!]␊
    ␊
      """All values that are not contained in given list."""␊
      updatedAt_not_in: [DateTime!]␊
    ␊
      """All values less than the given value."""␊
      updatedAt_lt: DateTime␊
    ␊
      """All values less than or equal the given value."""␊
      updatedAt_lte: DateTime␊
    ␊
      """All values greater than the given value."""␊
      updatedAt_gt: DateTime␊
    ␊
      """All values greater than or equal the given value."""␊
      updatedAt_gte: DateTime␊
      isPublished: Boolean␊
    ␊
      """All values that are not equal to given value."""␊
      isPublished_not: Boolean␊
      title: String␊
    ␊
      """All values that are not equal to given value."""␊
      title_not: String␊
    ␊
      """All values that are contained in given list."""␊
      title_in: [String!]␊
    ␊
      """All values that are not contained in given list."""␊
      title_not_in: [String!]␊
    ␊
      """All values less than the given value."""␊
      title_lt: String␊
    ␊
      """All values less than or equal the given value."""␊
      title_lte: String␊
    ␊
      """All values greater than the given value."""␊
      title_gt: String␊
    ␊
      """All values greater than or equal the given value."""␊
      title_gte: String␊
    ␊
      """All values containing the given string."""␊
      title_contains: String␊
    ␊
      """All values not containing the given string."""␊
      title_not_contains: String␊
    ␊
      """All values starting with the given string."""␊
      title_starts_with: String␊
    ␊
      """All values not starting with the given string."""␊
      title_not_starts_with: String␊
    ␊
      """All values ending with the given string."""␊
      title_ends_with: String␊
    ␊
      """All values not ending with the given string."""␊
      title_not_ends_with: String␊
      text: String␊
    ␊
      """All values that are not equal to given value."""␊
      text_not: String␊
    ␊
      """All values that are contained in given list."""␊
      text_in: [String!]␊
    ␊
      """All values that are not contained in given list."""␊
      text_not_in: [String!]␊
    ␊
      """All values less than the given value."""␊
      text_lt: String␊
    ␊
      """All values less than or equal the given value."""␊
      text_lte: String␊
    ␊
      """All values greater than the given value."""␊
      text_gt: String␊
    ␊
      """All values greater than or equal the given value."""␊
      text_gte: String␊
    ␊
      """All values containing the given string."""␊
      text_contains: String␊
    ␊
      """All values not containing the given string."""␊
      text_not_contains: String␊
    ␊
      """All values starting with the given string."""␊
      text_starts_with: String␊
    ␊
      """All values not starting with the given string."""␊
      text_not_starts_with: String␊
    ␊
      """All values ending with the given string."""␊
      text_ends_with: String␊
    ␊
      """All values not ending with the given string."""␊
      text_not_ends_with: String␊
      author: UserWhereInput␊
    }␊
    ␊
    input PostWhereUniqueInput {␊
      id: ID␊
    }␊
    ␊
    type Query {␊
      posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!␊
      users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!␊
      post(where: PostWhereUniqueInput!): Post␊
      user(where: UserWhereUniqueInput!): User␊
      postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!␊
      usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!␊
    ␊
      """Fetches an object given its ID"""␊
      node(␊
        """The ID of an object"""␊
        id: ID!␊
      ): Node␊
    }␊
    ␊
    type Subscription {␊
      post(where: PostSubscriptionWhereInput): PostSubscriptionPayload␊
      user(where: UserSubscriptionWhereInput): UserSubscriptionPayload␊
    }␊
    ␊
    type User implements Node {␊
      id: ID!␊
      email: String!␊
      password: String!␊
      name: String!␊
      posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]␊
    }␊
    ␊
    """A connection to a list of items."""␊
    type UserConnection {␊
      """Information to aid in pagination."""␊
      pageInfo: PageInfo!␊
    ␊
      """A list of edges."""␊
      edges: [UserEdge]!␊
      aggregate: AggregateUser!␊
    }␊
    ␊
    input UserCreateInput {␊
      email: String!␊
      password: String!␊
      name: String!␊
      posts: PostCreateManyWithoutAuthorInput␊
    }␊
    ␊
    input UserCreateOneWithoutPostsInput {␊
      create: UserCreateWithoutPostsInput␊
      connect: UserWhereUniqueInput␊
    }␊
    ␊
    input UserCreateWithoutPostsInput {␊
      email: String!␊
      password: String!␊
      name: String!␊
    }␊
    ␊
    """An edge in a connection."""␊
    type UserEdge {␊
      """The item at the end of the edge."""␊
      node: User!␊
    ␊
      """A cursor for use in pagination."""␊
      cursor: String!␊
    }␊
    ␊
    enum UserOrderByInput {␊
      id_ASC␊
      id_DESC␊
      email_ASC␊
      email_DESC␊
      password_ASC␊
      password_DESC␊
      name_ASC␊
      name_DESC␊
      updatedAt_ASC␊
      updatedAt_DESC␊
      createdAt_ASC␊
      createdAt_DESC␊
    }␊
    ␊
    type UserPreviousValues {␊
      id: ID!␊
      email: String!␊
      password: String!␊
      name: String!␊
    }␊
    ␊
    type UserSubscriptionPayload {␊
      mutation: MutationType!␊
      node: User␊
      updatedFields: [String!]␊
      previousValues: UserPreviousValues␊
    }␊
    ␊
    input UserSubscriptionWhereInput {␊
      """Logical AND on all given filters."""␊
      AND: [UserSubscriptionWhereInput!]␊
    ␊
      """Logical OR on all given filters."""␊
      OR: [UserSubscriptionWhereInput!]␊
    ␊
      """␊
      The subscription event gets dispatched when it's listed in mutation_in␊
      """␊
      mutation_in: [MutationType!]␊
    ␊
      """␊
      The subscription event gets only dispatched when one of the updated fields names is included in this list␊
      """␊
      updatedFields_contains: String␊
    ␊
      """␊
      The subscription event gets only dispatched when all of the field names included in this list have been updated␊
      """␊
      updatedFields_contains_every: [String!]␊
    ␊
      """␊
      The subscription event gets only dispatched when some of the field names included in this list have been updated␊
      """␊
      updatedFields_contains_some: [String!]␊
      node: UserWhereInput␊
    }␊
    ␊
    input UserUpdateInput {␊
      email: String␊
      password: String␊
      name: String␊
      posts: PostUpdateManyWithoutAuthorInput␊
    }␊
    ␊
    input UserUpdateOneWithoutPostsInput {␊
      create: UserCreateWithoutPostsInput␊
      connect: UserWhereUniqueInput␊
      delete: Boolean␊
      update: UserUpdateWithoutPostsDataInput␊
      upsert: UserUpsertWithoutPostsInput␊
    }␊
    ␊
    input UserUpdateWithoutPostsDataInput {␊
      email: String␊
      password: String␊
      name: String␊
    }␊
    ␊
    input UserUpsertWithoutPostsInput {␊
      update: UserUpdateWithoutPostsDataInput!␊
      create: UserCreateWithoutPostsInput!␊
    }␊
    ␊
    input UserWhereInput {␊
      """Logical AND on all given filters."""␊
      AND: [UserWhereInput!]␊
    ␊
      """Logical OR on all given filters."""␊
      OR: [UserWhereInput!]␊
      id: ID␊
    ␊
      """All values that are not equal to given value."""␊
      id_not: ID␊
    ␊
      """All values that are contained in given list."""␊
      id_in: [ID!]␊
    ␊
      """All values that are not contained in given list."""␊
      id_not_in: [ID!]␊
    ␊
      """All values less than the given value."""␊
      id_lt: ID␊
    ␊
      """All values less than or equal the given value."""␊
      id_lte: ID␊
    ␊
      """All values greater than the given value."""␊
      id_gt: ID␊
    ␊
      """All values greater than or equal the given value."""␊
      id_gte: ID␊
    ␊
      """All values containing the given string."""␊
      id_contains: ID␊
    ␊
      """All values not containing the given string."""␊
      id_not_contains: ID␊
    ␊
      """All values starting with the given string."""␊
      id_starts_with: ID␊
    ␊
      """All values not starting with the given string."""␊
      id_not_starts_with: ID␊
    ␊
      """All values ending with the given string."""␊
      id_ends_with: ID␊
    ␊
      """All values not ending with the given string."""␊
      id_not_ends_with: ID␊
      email: String␊
    ␊
      """All values that are not equal to given value."""␊
      email_not: String␊
    ␊
      """All values that are contained in given list."""␊
      email_in: [String!]␊
    ␊
      """All values that are not contained in given list."""␊
      email_not_in: [String!]␊
    ␊
      """All values less than the given value."""␊
      email_lt: String␊
    ␊
      """All values less than or equal the given value."""␊
      email_lte: String␊
    ␊
      """All values greater than the given value."""␊
      email_gt: String␊
    ␊
      """All values greater than or equal the given value."""␊
      email_gte: String␊
    ␊
      """All values containing the given string."""␊
      email_contains: String␊
    ␊
      """All values not containing the given string."""␊
      email_not_contains: String␊
    ␊
      """All values starting with the given string."""␊
      email_starts_with: String␊
    ␊
      """All values not starting with the given string."""␊
      email_not_starts_with: String␊
    ␊
      """All values ending with the given string."""␊
      email_ends_with: String␊
    ␊
      """All values not ending with the given string."""␊
      email_not_ends_with: String␊
      password: String␊
    ␊
      """All values that are not equal to given value."""␊
      password_not: String␊
    ␊
      """All values that are contained in given list."""␊
      password_in: [String!]␊
    ␊
      """All values that are not contained in given list."""␊
      password_not_in: [String!]␊
    ␊
      """All values less than the given value."""␊
      password_lt: String␊
    ␊
      """All values less than or equal the given value."""␊
      password_lte: String␊
    ␊
      """All values greater than the given value."""␊
      password_gt: String␊
    ␊
      """All values greater than or equal the given value."""␊
      password_gte: String␊
    ␊
      """All values containing the given string."""␊
      password_contains: String␊
    ␊
      """All values not containing the given string."""␊
      password_not_contains: String␊
    ␊
      """All values starting with the given string."""␊
      password_starts_with: String␊
    ␊
      """All values not starting with the given string."""␊
      password_not_starts_with: String␊
    ␊
      """All values ending with the given string."""␊
      password_ends_with: String␊
    ␊
      """All values not ending with the given string."""␊
      password_not_ends_with: String␊
      name: String␊
    ␊
      """All values that are not equal to given value."""␊
      name_not: String␊
    ␊
      """All values that are contained in given list."""␊
      name_in: [String!]␊
    ␊
      """All values that are not contained in given list."""␊
      name_not_in: [String!]␊
    ␊
      """All values less than the given value."""␊
      name_lt: String␊
    ␊
      """All values less than or equal the given value."""␊
      name_lte: String␊
    ␊
      """All values greater than the given value."""␊
      name_gt: String␊
    ␊
      """All values greater than or equal the given value."""␊
      name_gte: String␊
    ␊
      """All values containing the given string."""␊
      name_contains: String␊
    ␊
      """All values not containing the given string."""␊
      name_not_contains: String␊
    ␊
      """All values starting with the given string."""␊
      name_starts_with: String␊
    ␊
      """All values not starting with the given string."""␊
      name_not_starts_with: String␊
    ␊
      """All values ending with the given string."""␊
      name_ends_with: String␊
    ␊
      """All values not ending with the given string."""␊
      name_not_ends_with: String␊
      posts_every: PostWhereInput␊
      posts_some: PostWhereInput␊
      posts_none: PostWhereInput␊
    }␊
    ␊
    input UserWhereUniqueInput {␊
      id: ID␊
      email: String␊
    }␊
    ``
