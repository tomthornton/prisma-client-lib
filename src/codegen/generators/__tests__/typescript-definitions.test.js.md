# Snapshot report for `dist/codegen/typescript-definitions.test.js`

The actual snapshot is saved in `typescript-definitions.test.js.snap`.

Generated by [AVA](https://ava.li).

## typescript definitions generator

> Snapshot 1

    `// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.␊
    // Please don't change this file manually but run `prisma generate` to update it.␊
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/␊
    ␊
    import { DocumentNode } from "graphql";␊
    import {␊
      makePrismaClientClass,␊
      BaseClientOptions,␊
      Model␊
    } from "prisma-client-lib";␊
    import { typeDefs } from "./prisma-schema";␊
    ␊
    export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &␊
      U[keyof U];␊
    ␊
    export interface Exists {␊
      post: (where?: PostWhereInput) => Promise<boolean>;␊
      user: (where?: UserWhereInput) => Promise<boolean>;␊
    }␊
    ␊
    export interface Node {}␊
    ␊
    export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;␊
    ␊
    export interface Fragmentable {␊
      $fragment<T>(fragment: string | DocumentNode): Promise<T>;␊
    }␊
    ␊
    export interface Prisma {␊
      $exists: Exists;␊
      $graphql: <T = any>(␊
        query: string,␊
        variables?: { [key: string]: any }␊
      ) => Promise<T>;␊
    ␊
      /**␊
       * Queries␊
       */␊
    ␊
      posts: (␊
        args?: {␊
          where?: PostWhereInput;␊
          orderBy?: PostOrderByInput;␊
          skip?: Int;␊
          after?: String;␊
          before?: String;␊
          first?: Int;␊
          last?: Int;␊
        }␊
      ) => FragmentableArray<Post>;␊
      users: (␊
        args?: {␊
          where?: UserWhereInput;␊
          orderBy?: UserOrderByInput;␊
          skip?: Int;␊
          after?: String;␊
          before?: String;␊
          first?: Int;␊
          last?: Int;␊
        }␊
      ) => FragmentableArray<User>;␊
      post: (where: PostWhereUniqueInput) => PostPromise;␊
      user: (where: UserWhereUniqueInput) => UserPromise;␊
      postsConnection: (␊
        args?: {␊
          where?: PostWhereInput;␊
          orderBy?: PostOrderByInput;␊
          skip?: Int;␊
          after?: String;␊
          before?: String;␊
          first?: Int;␊
          last?: Int;␊
        }␊
      ) => PostConnectionPromise;␊
      usersConnection: (␊
        args?: {␊
          where?: UserWhereInput;␊
          orderBy?: UserOrderByInput;␊
          skip?: Int;␊
          after?: String;␊
          before?: String;␊
          first?: Int;␊
          last?: Int;␊
        }␊
      ) => UserConnectionPromise;␊
      node: (args: { id: ID_Output }) => Node;␊
    ␊
      /**␊
       * Mutations␊
       */␊
    ␊
      createPost: (data: PostCreateInput) => PostPromise;␊
      createUser: (data: UserCreateInput) => UserPromise;␊
      updatePost: (␊
        args: { data: PostUpdateInput; where: PostWhereUniqueInput }␊
      ) => PostPromise;␊
      updateUser: (␊
        args: { data: UserUpdateInput; where: UserWhereUniqueInput }␊
      ) => UserPromise;␊
      deletePost: (where: PostWhereUniqueInput) => PostPromise;␊
      deleteUser: (where: UserWhereUniqueInput) => UserPromise;␊
      upsertPost: (␊
        args: {␊
          where: PostWhereUniqueInput;␊
          create: PostCreateInput;␊
          update: PostUpdateInput;␊
        }␊
      ) => PostPromise;␊
      upsertUser: (␊
        args: {␊
          where: UserWhereUniqueInput;␊
          create: UserCreateInput;␊
          update: UserUpdateInput;␊
        }␊
      ) => UserPromise;␊
      updateManyPosts: (␊
        args: { data: PostUpdateInput; where: PostWhereInput }␊
      ) => BatchPayloadPromise;␊
      updateManyUsers: (␊
        args: { data: UserUpdateInput; where: UserWhereInput }␊
      ) => BatchPayloadPromise;␊
      deleteManyPosts: (where: PostWhereInput) => BatchPayloadPromise;␊
      deleteManyUsers: (where: UserWhereInput) => BatchPayloadPromise;␊
    ␊
      /**␊
       * Subscriptions␊
       */␊
    ␊
      $subscribe: Subscription;␊
    }␊
    ␊
    export interface Subscription {␊
      post: (␊
        where?: PostSubscriptionWhereInput␊
      ) => PostSubscriptionPayloadSubscription;␊
      user: (␊
        where?: UserSubscriptionWhereInput␊
      ) => UserSubscriptionPayloadSubscription;␊
    }␊
    ␊
    export interface ClientConstructor<T> {␊
      new (options?: BaseClientOptions): T;␊
    }␊
    ␊
    /**␊
     * Types␊
     */␊
    ␊
    export type PostOrderByInput =␊
      | "id_ASC"␊
      | "id_DESC"␊
      | "createdAt_ASC"␊
      | "createdAt_DESC"␊
      | "updatedAt_ASC"␊
      | "updatedAt_DESC"␊
      | "isPublished_ASC"␊
      | "isPublished_DESC"␊
      | "title_ASC"␊
      | "title_DESC"␊
      | "text_ASC"␊
      | "text_DESC";␊
    ␊
    export type UserOrderByInput =␊
      | "id_ASC"␊
      | "id_DESC"␊
      | "email_ASC"␊
      | "email_DESC"␊
      | "password_ASC"␊
      | "password_DESC"␊
      | "name_ASC"␊
      | "name_DESC"␊
      | "updatedAt_ASC"␊
      | "updatedAt_DESC"␊
      | "createdAt_ASC"␊
      | "createdAt_DESC";␊
    ␊
    export type MutationType = "CREATED" | "UPDATED" | "DELETED";␊
    ␊
    export interface UserCreateOneWithoutPostsInput {␊
      create?: UserCreateWithoutPostsInput;␊
      connect?: UserWhereUniqueInput;␊
    }␊
    ␊
    export interface PostWhereInput {␊
      AND?: PostWhereInput[] | PostWhereInput;␊
      OR?: PostWhereInput[] | PostWhereInput;␊
      id?: ID_Input;␊
      id_not?: ID_Input;␊
      id_in?: ID_Input[] | ID_Input;␊
      id_not_in?: ID_Input[] | ID_Input;␊
      id_lt?: ID_Input;␊
      id_lte?: ID_Input;␊
      id_gt?: ID_Input;␊
      id_gte?: ID_Input;␊
      id_contains?: ID_Input;␊
      id_not_contains?: ID_Input;␊
      id_starts_with?: ID_Input;␊
      id_not_starts_with?: ID_Input;␊
      id_ends_with?: ID_Input;␊
      id_not_ends_with?: ID_Input;␊
      createdAt?: DateTimeInput;␊
      createdAt_not?: DateTimeInput;␊
      createdAt_in?: DateTimeInput[] | DateTimeInput;␊
      createdAt_not_in?: DateTimeInput[] | DateTimeInput;␊
      createdAt_lt?: DateTimeInput;␊
      createdAt_lte?: DateTimeInput;␊
      createdAt_gt?: DateTimeInput;␊
      createdAt_gte?: DateTimeInput;␊
      updatedAt?: DateTimeInput;␊
      updatedAt_not?: DateTimeInput;␊
      updatedAt_in?: DateTimeInput[] | DateTimeInput;␊
      updatedAt_not_in?: DateTimeInput[] | DateTimeInput;␊
      updatedAt_lt?: DateTimeInput;␊
      updatedAt_lte?: DateTimeInput;␊
      updatedAt_gt?: DateTimeInput;␊
      updatedAt_gte?: DateTimeInput;␊
      isPublished?: Boolean;␊
      isPublished_not?: Boolean;␊
      title?: String;␊
      title_not?: String;␊
      title_in?: String[] | String;␊
      title_not_in?: String[] | String;␊
      title_lt?: String;␊
      title_lte?: String;␊
      title_gt?: String;␊
      title_gte?: String;␊
      title_contains?: String;␊
      title_not_contains?: String;␊
      title_starts_with?: String;␊
      title_not_starts_with?: String;␊
      title_ends_with?: String;␊
      title_not_ends_with?: String;␊
      text?: String;␊
      text_not?: String;␊
      text_in?: String[] | String;␊
      text_not_in?: String[] | String;␊
      text_lt?: String;␊
      text_lte?: String;␊
      text_gt?: String;␊
      text_gte?: String;␊
      text_contains?: String;␊
      text_not_contains?: String;␊
      text_starts_with?: String;␊
      text_not_starts_with?: String;␊
      text_ends_with?: String;␊
      text_not_ends_with?: String;␊
      author?: UserWhereInput;␊
    }␊
    ␊
    export interface PostCreateManyWithoutAuthorInput {␊
      create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;␊
      connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;␊
    }␊
    ␊
    export interface UserWhereInput {␊
      AND?: UserWhereInput[] | UserWhereInput;␊
      OR?: UserWhereInput[] | UserWhereInput;␊
      id?: ID_Input;␊
      id_not?: ID_Input;␊
      id_in?: ID_Input[] | ID_Input;␊
      id_not_in?: ID_Input[] | ID_Input;␊
      id_lt?: ID_Input;␊
      id_lte?: ID_Input;␊
      id_gt?: ID_Input;␊
      id_gte?: ID_Input;␊
      id_contains?: ID_Input;␊
      id_not_contains?: ID_Input;␊
      id_starts_with?: ID_Input;␊
      id_not_starts_with?: ID_Input;␊
      id_ends_with?: ID_Input;␊
      id_not_ends_with?: ID_Input;␊
      email?: String;␊
      email_not?: String;␊
      email_in?: String[] | String;␊
      email_not_in?: String[] | String;␊
      email_lt?: String;␊
      email_lte?: String;␊
      email_gt?: String;␊
      email_gte?: String;␊
      email_contains?: String;␊
      email_not_contains?: String;␊
      email_starts_with?: String;␊
      email_not_starts_with?: String;␊
      email_ends_with?: String;␊
      email_not_ends_with?: String;␊
      password?: String;␊
      password_not?: String;␊
      password_in?: String[] | String;␊
      password_not_in?: String[] | String;␊
      password_lt?: String;␊
      password_lte?: String;␊
      password_gt?: String;␊
      password_gte?: String;␊
      password_contains?: String;␊
      password_not_contains?: String;␊
      password_starts_with?: String;␊
      password_not_starts_with?: String;␊
      password_ends_with?: String;␊
      password_not_ends_with?: String;␊
      name?: String;␊
      name_not?: String;␊
      name_in?: String[] | String;␊
      name_not_in?: String[] | String;␊
      name_lt?: String;␊
      name_lte?: String;␊
      name_gt?: String;␊
      name_gte?: String;␊
      name_contains?: String;␊
      name_not_contains?: String;␊
      name_starts_with?: String;␊
      name_not_starts_with?: String;␊
      name_ends_with?: String;␊
      name_not_ends_with?: String;␊
      posts_every?: PostWhereInput;␊
      posts_some?: PostWhereInput;␊
      posts_none?: PostWhereInput;␊
    }␊
    ␊
    export interface PostUpdateManyWithoutAuthorInput {␊
      create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;␊
      connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;␊
      disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;␊
      delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;␊
      update?:␊
        | PostUpdateWithWhereUniqueWithoutAuthorInput[]␊
        | PostUpdateWithWhereUniqueWithoutAuthorInput;␊
      upsert?:␊
        | PostUpsertWithWhereUniqueWithoutAuthorInput[]␊
        | PostUpsertWithWhereUniqueWithoutAuthorInput;␊
    }␊
    ␊
    export interface PostUpdateInput {␊
      isPublished?: Boolean;␊
      title?: String;␊
      text?: String;␊
      author?: UserUpdateOneWithoutPostsInput;␊
    }␊
    ␊
    export interface UserUpdateInput {␊
      email?: String;␊
      password?: String;␊
      name?: String;␊
      posts?: PostUpdateManyWithoutAuthorInput;␊
    }␊
    ␊
    export interface PostCreateWithoutAuthorInput {␊
      isPublished?: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface UserUpsertWithoutPostsInput {␊
      update: UserUpdateWithoutPostsDataInput;␊
      create: UserCreateWithoutPostsInput;␊
    }␊
    ␊
    export interface UserSubscriptionWhereInput {␊
      AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;␊
      OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;␊
      mutation_in?: MutationType[] | MutationType;␊
      updatedFields_contains?: String;␊
      updatedFields_contains_every?: String[] | String;␊
      updatedFields_contains_some?: String[] | String;␊
      node?: UserWhereInput;␊
    }␊
    ␊
    export interface UserUpdateWithoutPostsDataInput {␊
      email?: String;␊
      password?: String;␊
      name?: String;␊
    }␊
    ␊
    export type PostWhereUniqueInput = AtLeastOne<{␊
      id: ID_Input;␊
    }>;␊
    ␊
    export interface PostUpsertWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput;␊
      update: PostUpdateWithoutAuthorDataInput;␊
      create: PostCreateWithoutAuthorInput;␊
    }␊
    ␊
    export interface UserCreateInput {␊
      email: String;␊
      password: String;␊
      name: String;␊
      posts?: PostCreateManyWithoutAuthorInput;␊
    }␊
    ␊
    export interface UserCreateWithoutPostsInput {␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserUpdateOneWithoutPostsInput {␊
      create?: UserCreateWithoutPostsInput;␊
      connect?: UserWhereUniqueInput;␊
      delete?: Boolean;␊
      update?: UserUpdateWithoutPostsDataInput;␊
      upsert?: UserUpsertWithoutPostsInput;␊
    }␊
    ␊
    export interface PostCreateInput {␊
      isPublished?: Boolean;␊
      title: String;␊
      text: String;␊
      author: UserCreateOneWithoutPostsInput;␊
    }␊
    ␊
    export interface PostUpdateWithoutAuthorDataInput {␊
      isPublished?: Boolean;␊
      title?: String;␊
      text?: String;␊
    }␊
    ␊
    export type UserWhereUniqueInput = AtLeastOne<{␊
      id: ID_Input;␊
      email?: String;␊
    }>;␊
    ␊
    export interface PostSubscriptionWhereInput {␊
      AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;␊
      OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;␊
      mutation_in?: MutationType[] | MutationType;␊
      updatedFields_contains?: String;␊
      updatedFields_contains_every?: String[] | String;␊
      updatedFields_contains_some?: String[] | String;␊
      node?: PostWhereInput;␊
    }␊
    ␊
    export interface PostUpdateWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput;␊
      data: PostUpdateWithoutAuthorDataInput;␊
    }␊
    ␊
    /*␊
     * An object with an ID␊
    ␊
     */␊
    export interface NodeNode {␊
      id: ID_Output;␊
    }␊
    ␊
    export interface UserPreviousValues {␊
      id: ID_Output;␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserPreviousValuesPromise␊
      extends Promise<UserPreviousValues>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
    }␊
    ␊
    export interface UserPreviousValuesSubscription␊
      extends Promise<AsyncIterator<UserPreviousValues>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      email: () => Promise<AsyncIterator<String>>;␊
      password: () => Promise<AsyncIterator<String>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface PostConnection {␊
      pageInfo: PageInfo;␊
      edges: PostEdge[];␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface PostConnectionPromise␊
      extends Promise<PostConnection>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoPromise>() => T;␊
      edges: <T = FragmentableArray<PostEdge>>() => T;␊
      aggregate: <T = AggregatePostPromise>() => T;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface PostConnectionSubscription␊
      extends Promise<AsyncIterator<PostConnection>>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoSubscription>() => T;␊
      edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;␊
      aggregate: <T = AggregatePostSubscription>() => T;␊
    }␊
    ␊
    export interface Post extends Node {␊
      id: ID_Output;␊
      createdAt: DateTimeOutput;␊
      updatedAt: DateTimeOutput;␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostPromise extends Promise<Post>, Fragmentable, Node {␊
      id: () => Promise<ID_Output>;␊
      createdAt: () => Promise<DateTimeOutput>;␊
      updatedAt: () => Promise<DateTimeOutput>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
      author: <T = UserPromise>() => T;␊
    }␊
    ␊
    export interface PostSubscription␊
      extends Promise<AsyncIterator<Post>>,␊
        Fragmentable,␊
        Node {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      isPublished: () => Promise<AsyncIterator<Boolean>>;␊
      title: () => Promise<AsyncIterator<String>>;␊
      text: () => Promise<AsyncIterator<String>>;␊
      author: <T = UserSubscription>() => T;␊
    }␊
    ␊
    /*␊
     * Information about pagination in a connection.␊
    ␊
     */␊
    export interface PageInfo {␊
      hasNextPage: Boolean;␊
      hasPreviousPage: Boolean;␊
      startCursor?: String;␊
      endCursor?: String;␊
    }␊
    ␊
    /*␊
     * Information about pagination in a connection.␊
    ␊
     */␊
    export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {␊
      hasNextPage: () => Promise<Boolean>;␊
      hasPreviousPage: () => Promise<Boolean>;␊
      startCursor: () => Promise<String>;␊
      endCursor: () => Promise<String>;␊
    }␊
    ␊
    /*␊
     * Information about pagination in a connection.␊
    ␊
     */␊
    export interface PageInfoSubscription␊
      extends Promise<AsyncIterator<PageInfo>>,␊
        Fragmentable {␊
      hasNextPage: () => Promise<AsyncIterator<Boolean>>;␊
      hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;␊
      startCursor: () => Promise<AsyncIterator<String>>;␊
      endCursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface PostSubscriptionPayload {␊
      mutation: MutationType;␊
      node: Post;␊
      updatedFields: String[];␊
      previousValues: PostPreviousValues;␊
    }␊
    ␊
    export interface PostSubscriptionPayloadPromise␊
      extends Promise<PostSubscriptionPayload>,␊
        Fragmentable {␊
      mutation: () => Promise<MutationType>;␊
      node: <T = PostPromise>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T = PostPreviousValuesPromise>() => T;␊
    }␊
    ␊
    export interface PostSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<PostSubscriptionPayload>>,␊
        Fragmentable {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T = PostSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T = PostPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    export interface BatchPayload {␊
      count: Long;␊
    }␊
    ␊
    export interface BatchPayloadPromise␊
      extends Promise<BatchPayload>,␊
        Fragmentable {␊
      count: () => Promise<Long>;␊
    }␊
    ␊
    export interface BatchPayloadSubscription␊
      extends Promise<AsyncIterator<BatchPayload>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Long>>;␊
    }␊
    ␊
    export interface PostPreviousValues {␊
      id: ID_Output;␊
      createdAt: DateTimeOutput;␊
      updatedAt: DateTimeOutput;␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostPreviousValuesPromise␊
      extends Promise<PostPreviousValues>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      createdAt: () => Promise<DateTimeOutput>;␊
      updatedAt: () => Promise<DateTimeOutput>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
    }␊
    ␊
    export interface PostPreviousValuesSubscription␊
      extends Promise<AsyncIterator<PostPreviousValues>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;␊
      isPublished: () => Promise<AsyncIterator<Boolean>>;␊
      title: () => Promise<AsyncIterator<String>>;␊
      text: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface User extends Node {␊
      id: ID_Output;␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserPromise extends Promise<User>, Fragmentable, Node {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
      posts: <T = FragmentableArray<Post>>(␊
        args?: {␊
          where?: PostWhereInput;␊
          orderBy?: PostOrderByInput;␊
          skip?: Int;␊
          after?: String;␊
          before?: String;␊
          first?: Int;␊
          last?: Int;␊
        }␊
      ) => T;␊
    }␊
    ␊
    export interface UserSubscription␊
      extends Promise<AsyncIterator<User>>,␊
        Fragmentable,␊
        Node {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      email: () => Promise<AsyncIterator<String>>;␊
      password: () => Promise<AsyncIterator<String>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
      posts: <T = Promise<AsyncIterator<PostSubscription>>>(␊
        args?: {␊
          where?: PostWhereInput;␊
          orderBy?: PostOrderByInput;␊
          skip?: Int;␊
          after?: String;␊
          before?: String;␊
          first?: Int;␊
          last?: Int;␊
        }␊
      ) => T;␊
    }␊
    ␊
    export interface AggregateUser {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregateUserPromise␊
      extends Promise<AggregateUser>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregateUserSubscription␊
      extends Promise<AsyncIterator<AggregateUser>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface UserSubscriptionPayload {␊
      mutation: MutationType;␊
      node: User;␊
      updatedFields: String[];␊
      previousValues: UserPreviousValues;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadPromise␊
      extends Promise<UserSubscriptionPayload>,␊
        Fragmentable {␊
      mutation: () => Promise<MutationType>;␊
      node: <T = UserPromise>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T = UserPreviousValuesPromise>() => T;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<UserSubscriptionPayload>>,␊
        Fragmentable {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T = UserSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T = UserPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface UserEdge {␊
      node: User;␊
      cursor: String;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {␊
      node: <T = UserPromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface UserEdgeSubscription␊
      extends Promise<AsyncIterator<UserEdge>>,␊
        Fragmentable {␊
      node: <T = UserSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface PostEdge {␊
      node: Post;␊
      cursor: String;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {␊
      node: <T = PostPromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    /*␊
     * An edge in a connection.␊
    ␊
     */␊
    export interface PostEdgeSubscription␊
      extends Promise<AsyncIterator<PostEdge>>,␊
        Fragmentable {␊
      node: <T = PostSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface AggregatePost {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregatePostPromise␊
      extends Promise<AggregatePost>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregatePostSubscription␊
      extends Promise<AsyncIterator<AggregatePost>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface UserConnection {␊
      pageInfo: PageInfo;␊
      edges: UserEdge[];␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface UserConnectionPromise␊
      extends Promise<UserConnection>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoPromise>() => T;␊
      edges: <T = FragmentableArray<UserEdge>>() => T;␊
      aggregate: <T = AggregateUserPromise>() => T;␊
    }␊
    ␊
    /*␊
     * A connection to a list of items.␊
    ␊
     */␊
    export interface UserConnectionSubscription␊
      extends Promise<AsyncIterator<UserConnection>>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoSubscription>() => T;␊
      edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;␊
      aggregate: <T = AggregateUserSubscription>() => T;␊
    }␊
    ␊
    /*␊
    The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. ␊
    */␊
    export type Int = number;␊
    ␊
    /*␊
    The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.␊
    */␊
    export type ID_Input = string | number;␊
    export type ID_Output = string;␊
    ␊
    /*␊
    The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.␊
    */␊
    export type String = string;␊
    ␊
    /*␊
    The `Long` scalar type represents non-fractional signed whole numeric values.␊
    Long can represent values between -(2^63) and 2^63 - 1.␊
    */␊
    export type Long = string;␊
    ␊
    /*␊
    The `Boolean` scalar type represents `true` or `false`.␊
    */␊
    export type Boolean = boolean;␊
    ␊
    /*␊
    DateTime scalar input type, allowing Date␊
    */␊
    export type DateTimeInput = Date | string;␊
    ␊
    /*␊
    DateTime scalar output type, which is always a string␊
    */␊
    export type DateTimeOutput = string;␊
    ␊
    /**␊
     * Model Metadata␊
     */␊
    ␊
    export const models: Model[] = [];␊
    ␊
    /**␊
     * Type Defs␊
     */␊
    ␊
    export const prisma: Prisma;␊
    `
