# Snapshot report for `dist/codegen/generators/__tests__/typescript-client.test.js`

The actual snapshot is saved in `typescript-client.test.js.snap`.

Generated by [AVA](https://ava.li).

## typescript generator

> Snapshot 1

    `// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.␊
    // Please don't change this file manually but run `prisma generate` to update it.␊
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/␊
    ␊
    import { DocumentNode } from "graphql";␊
    import {␊
      makePrismaClientClass,␊
      BaseClientOptions,␊
      Model␊
    } from "prisma-client-lib";␊
    import { typeDefs } from "./prisma-schema";␊
    ␊
    export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &␊
      U[keyof U];␊
    ␊
    export type Maybe<T> = T | undefined | null;␊
    ␊
    export interface Exists {␊
      post: (where?: PostWhereInput) => Promise<boolean>;␊
      user: (where?: UserWhereInput) => Promise<boolean>;␊
    }␊
    ␊
    export interface Node {}␊
    ␊
    export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;␊
    ␊
    export interface Fragmentable {␊
      $fragment<T>(fragment: string | DocumentNode): Promise<T>;␊
    }␊
    ␊
    export interface Prisma {␊
      $exists: Exists;␊
      $graphql: <T = any>(␊
        query: string,␊
        variables?: { [key: string]: any }␊
      ) => Promise<T>;␊
    ␊
      /**␊
       * Queries␊
       */␊
    ␊
      post: (where: PostWhereUniqueInput) => PostNullablePromise;␊
      posts: (args?: {␊
        where?: PostWhereInput;␊
        orderBy?: PostOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => FragmentableArray<Post>;␊
      postsConnection: (args?: {␊
        where?: PostWhereInput;␊
        orderBy?: PostOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => PostConnectionPromise;␊
      user: (where: UserWhereUniqueInput) => UserNullablePromise;␊
      users: (args?: {␊
        where?: UserWhereInput;␊
        orderBy?: UserOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => FragmentableArray<User>;␊
      usersConnection: (args?: {␊
        where?: UserWhereInput;␊
        orderBy?: UserOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => UserConnectionPromise;␊
      node: (args: { id: ID_Output }) => Node;␊
    ␊
      /**␊
       * Mutations␊
       */␊
    ␊
      createPost: (data: PostCreateInput) => PostPromise;␊
      updatePost: (args: {␊
        data: PostUpdateInput;␊
        where: PostWhereUniqueInput;␊
      }) => PostPromise;␊
      updateManyPosts: (args: {␊
        data: PostUpdateManyMutationInput;␊
        where?: PostWhereInput;␊
      }) => BatchPayloadPromise;␊
      upsertPost: (args: {␊
        where: PostWhereUniqueInput;␊
        create: PostCreateInput;␊
        update: PostUpdateInput;␊
      }) => PostPromise;␊
      deletePost: (where: PostWhereUniqueInput) => PostPromise;␊
      deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;␊
      createUser: (data: UserCreateInput) => UserPromise;␊
      updateUser: (args: {␊
        data: UserUpdateInput;␊
        where: UserWhereUniqueInput;␊
      }) => UserPromise;␊
      updateManyUsers: (args: {␊
        data: UserUpdateManyMutationInput;␊
        where?: UserWhereInput;␊
      }) => BatchPayloadPromise;␊
      upsertUser: (args: {␊
        where: UserWhereUniqueInput;␊
        create: UserCreateInput;␊
        update: UserUpdateInput;␊
      }) => UserPromise;␊
      deleteUser: (where: UserWhereUniqueInput) => UserPromise;␊
      deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;␊
    ␊
      /**␊
       * Subscriptions␊
       */␊
    ␊
      $subscribe: Subscription;␊
    }␊
    ␊
    export interface Subscription {␊
      post: (␊
        where?: PostSubscriptionWhereInput␊
      ) => PostSubscriptionPayloadSubscription;␊
      user: (␊
        where?: UserSubscriptionWhereInput␊
      ) => UserSubscriptionPayloadSubscription;␊
    }␊
    ␊
    export interface ClientConstructor<T> {␊
      new (options?: BaseClientOptions): T;␊
    }␊
    ␊
    /**␊
     * Types␊
     */␊
    ␊
    export type PostOrderByInput =␊
      | "id_ASC"␊
      | "id_DESC"␊
      | "isPublished_ASC"␊
      | "isPublished_DESC"␊
      | "title_ASC"␊
      | "title_DESC"␊
      | "text_ASC"␊
      | "text_DESC";␊
    ␊
    export type UserOrderByInput =␊
      | "id_ASC"␊
      | "id_DESC"␊
      | "email_ASC"␊
      | "email_DESC"␊
      | "password_ASC"␊
      | "password_DESC"␊
      | "name_ASC"␊
      | "name_DESC";␊
    ␊
    export type MutationType = "CREATED" | "UPDATED" | "DELETED";␊
    ␊
    export interface UserUpdateOneRequiredWithoutPostsInput {␊
      create?: Maybe<UserCreateWithoutPostsInput>;␊
      update?: Maybe<UserUpdateWithoutPostsDataInput>;␊
      upsert?: Maybe<UserUpsertWithoutPostsInput>;␊
      connect?: Maybe<UserWhereUniqueInput>;␊
    }␊
    ␊
    export type PostWhereUniqueInput = AtLeastOne<{␊
      id: Maybe<ID_Input>;␊
    }>;␊
    ␊
    export interface PostUpdateManyWithoutAuthorInput {␊
      create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;␊
      delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;␊
      connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;␊
      set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;␊
      disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;␊
      update?: Maybe<␊
        | PostUpdateWithWhereUniqueWithoutAuthorInput[]␊
        | PostUpdateWithWhereUniqueWithoutAuthorInput␊
      >;␊
      upsert?: Maybe<␊
        | PostUpsertWithWhereUniqueWithoutAuthorInput[]␊
        | PostUpsertWithWhereUniqueWithoutAuthorInput␊
      >;␊
      deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;␊
      updateMany?: Maybe<␊
        PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput␊
      >;␊
    }␊
    ␊
    export interface UserCreateInput {␊
      email: String;␊
      password: String;␊
      name: String;␊
      posts?: Maybe<PostCreateManyWithoutAuthorInput>;␊
    }␊
    ␊
    export interface PostUpdateManyMutationInput {␊
      isPublished?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      text?: Maybe<String>;␊
    }␊
    ␊
    export interface UserSubscriptionWhereInput {␊
      mutation_in?: Maybe<MutationType[] | MutationType>;␊
      updatedFields_contains?: Maybe<String>;␊
      updatedFields_contains_every?: Maybe<String[] | String>;␊
      updatedFields_contains_some?: Maybe<String[] | String>;␊
      node?: Maybe<UserWhereInput>;␊
      AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;␊
      OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;␊
      NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;␊
    }␊
    ␊
    export interface PostCreateInput {␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
      author: UserCreateOneWithoutPostsInput;␊
    }␊
    ␊
    export interface UserUpdateManyMutationInput {␊
      email?: Maybe<String>;␊
      password?: Maybe<String>;␊
      name?: Maybe<String>;␊
    }␊
    ␊
    export interface UserCreateOneWithoutPostsInput {␊
      create?: Maybe<UserCreateWithoutPostsInput>;␊
      connect?: Maybe<UserWhereUniqueInput>;␊
    }␊
    ␊
    export interface PostUpdateManyWithWhereNestedInput {␊
      where: PostScalarWhereInput;␊
      data: PostUpdateManyDataInput;␊
    }␊
    ␊
    export interface UserCreateWithoutPostsInput {␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export type UserWhereUniqueInput = AtLeastOne<{␊
      id: Maybe<ID_Input>;␊
    }>;␊
    ␊
    export interface PostUpdateInput {␊
      isPublished?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      text?: Maybe<String>;␊
      author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;␊
    }␊
    ␊
    export interface PostUpdateWithoutAuthorDataInput {␊
      isPublished?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      text?: Maybe<String>;␊
    }␊
    ␊
    export interface UserUpdateInput {␊
      email?: Maybe<String>;␊
      password?: Maybe<String>;␊
      name?: Maybe<String>;␊
      posts?: Maybe<PostUpdateManyWithoutAuthorInput>;␊
    }␊
    ␊
    export interface UserWhereInput {␊
      id?: Maybe<ID_Input>;␊
      id_not?: Maybe<ID_Input>;␊
      id_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_not_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_lt?: Maybe<ID_Input>;␊
      id_lte?: Maybe<ID_Input>;␊
      id_gt?: Maybe<ID_Input>;␊
      id_gte?: Maybe<ID_Input>;␊
      id_contains?: Maybe<ID_Input>;␊
      id_not_contains?: Maybe<ID_Input>;␊
      id_starts_with?: Maybe<ID_Input>;␊
      id_not_starts_with?: Maybe<ID_Input>;␊
      id_ends_with?: Maybe<ID_Input>;␊
      id_not_ends_with?: Maybe<ID_Input>;␊
      email?: Maybe<String>;␊
      email_not?: Maybe<String>;␊
      email_in?: Maybe<String[] | String>;␊
      email_not_in?: Maybe<String[] | String>;␊
      email_lt?: Maybe<String>;␊
      email_lte?: Maybe<String>;␊
      email_gt?: Maybe<String>;␊
      email_gte?: Maybe<String>;␊
      email_contains?: Maybe<String>;␊
      email_not_contains?: Maybe<String>;␊
      email_starts_with?: Maybe<String>;␊
      email_not_starts_with?: Maybe<String>;␊
      email_ends_with?: Maybe<String>;␊
      email_not_ends_with?: Maybe<String>;␊
      password?: Maybe<String>;␊
      password_not?: Maybe<String>;␊
      password_in?: Maybe<String[] | String>;␊
      password_not_in?: Maybe<String[] | String>;␊
      password_lt?: Maybe<String>;␊
      password_lte?: Maybe<String>;␊
      password_gt?: Maybe<String>;␊
      password_gte?: Maybe<String>;␊
      password_contains?: Maybe<String>;␊
      password_not_contains?: Maybe<String>;␊
      password_starts_with?: Maybe<String>;␊
      password_not_starts_with?: Maybe<String>;␊
      password_ends_with?: Maybe<String>;␊
      password_not_ends_with?: Maybe<String>;␊
      name?: Maybe<String>;␊
      name_not?: Maybe<String>;␊
      name_in?: Maybe<String[] | String>;␊
      name_not_in?: Maybe<String[] | String>;␊
      name_lt?: Maybe<String>;␊
      name_lte?: Maybe<String>;␊
      name_gt?: Maybe<String>;␊
      name_gte?: Maybe<String>;␊
      name_contains?: Maybe<String>;␊
      name_not_contains?: Maybe<String>;␊
      name_starts_with?: Maybe<String>;␊
      name_not_starts_with?: Maybe<String>;␊
      name_ends_with?: Maybe<String>;␊
      name_not_ends_with?: Maybe<String>;␊
      posts_every?: Maybe<PostWhereInput>;␊
      posts_some?: Maybe<PostWhereInput>;␊
      posts_none?: Maybe<PostWhereInput>;␊
      AND?: Maybe<UserWhereInput[] | UserWhereInput>;␊
      OR?: Maybe<UserWhereInput[] | UserWhereInput>;␊
      NOT?: Maybe<UserWhereInput[] | UserWhereInput>;␊
    }␊
    ␊
    export interface UserUpdateWithoutPostsDataInput {␊
      email?: Maybe<String>;␊
      password?: Maybe<String>;␊
      name?: Maybe<String>;␊
    }␊
    ␊
    export interface PostUpdateManyDataInput {␊
      isPublished?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      text?: Maybe<String>;␊
    }␊
    ␊
    export interface PostCreateManyWithoutAuthorInput {␊
      create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;␊
      connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;␊
    }␊
    ␊
    export interface PostCreateWithoutAuthorInput {␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostWhereInput {␊
      id?: Maybe<ID_Input>;␊
      id_not?: Maybe<ID_Input>;␊
      id_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_not_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_lt?: Maybe<ID_Input>;␊
      id_lte?: Maybe<ID_Input>;␊
      id_gt?: Maybe<ID_Input>;␊
      id_gte?: Maybe<ID_Input>;␊
      id_contains?: Maybe<ID_Input>;␊
      id_not_contains?: Maybe<ID_Input>;␊
      id_starts_with?: Maybe<ID_Input>;␊
      id_not_starts_with?: Maybe<ID_Input>;␊
      id_ends_with?: Maybe<ID_Input>;␊
      id_not_ends_with?: Maybe<ID_Input>;␊
      isPublished?: Maybe<Boolean>;␊
      isPublished_not?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      title_not?: Maybe<String>;␊
      title_in?: Maybe<String[] | String>;␊
      title_not_in?: Maybe<String[] | String>;␊
      title_lt?: Maybe<String>;␊
      title_lte?: Maybe<String>;␊
      title_gt?: Maybe<String>;␊
      title_gte?: Maybe<String>;␊
      title_contains?: Maybe<String>;␊
      title_not_contains?: Maybe<String>;␊
      title_starts_with?: Maybe<String>;␊
      title_not_starts_with?: Maybe<String>;␊
      title_ends_with?: Maybe<String>;␊
      title_not_ends_with?: Maybe<String>;␊
      text?: Maybe<String>;␊
      text_not?: Maybe<String>;␊
      text_in?: Maybe<String[] | String>;␊
      text_not_in?: Maybe<String[] | String>;␊
      text_lt?: Maybe<String>;␊
      text_lte?: Maybe<String>;␊
      text_gt?: Maybe<String>;␊
      text_gte?: Maybe<String>;␊
      text_contains?: Maybe<String>;␊
      text_not_contains?: Maybe<String>;␊
      text_starts_with?: Maybe<String>;␊
      text_not_starts_with?: Maybe<String>;␊
      text_ends_with?: Maybe<String>;␊
      text_not_ends_with?: Maybe<String>;␊
      author?: Maybe<UserWhereInput>;␊
      AND?: Maybe<PostWhereInput[] | PostWhereInput>;␊
      OR?: Maybe<PostWhereInput[] | PostWhereInput>;␊
      NOT?: Maybe<PostWhereInput[] | PostWhereInput>;␊
    }␊
    ␊
    export interface UserUpsertWithoutPostsInput {␊
      update: UserUpdateWithoutPostsDataInput;␊
      create: UserCreateWithoutPostsInput;␊
    }␊
    ␊
    export interface PostScalarWhereInput {␊
      id?: Maybe<ID_Input>;␊
      id_not?: Maybe<ID_Input>;␊
      id_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_not_in?: Maybe<ID_Input[] | ID_Input>;␊
      id_lt?: Maybe<ID_Input>;␊
      id_lte?: Maybe<ID_Input>;␊
      id_gt?: Maybe<ID_Input>;␊
      id_gte?: Maybe<ID_Input>;␊
      id_contains?: Maybe<ID_Input>;␊
      id_not_contains?: Maybe<ID_Input>;␊
      id_starts_with?: Maybe<ID_Input>;␊
      id_not_starts_with?: Maybe<ID_Input>;␊
      id_ends_with?: Maybe<ID_Input>;␊
      id_not_ends_with?: Maybe<ID_Input>;␊
      isPublished?: Maybe<Boolean>;␊
      isPublished_not?: Maybe<Boolean>;␊
      title?: Maybe<String>;␊
      title_not?: Maybe<String>;␊
      title_in?: Maybe<String[] | String>;␊
      title_not_in?: Maybe<String[] | String>;␊
      title_lt?: Maybe<String>;␊
      title_lte?: Maybe<String>;␊
      title_gt?: Maybe<String>;␊
      title_gte?: Maybe<String>;␊
      title_contains?: Maybe<String>;␊
      title_not_contains?: Maybe<String>;␊
      title_starts_with?: Maybe<String>;␊
      title_not_starts_with?: Maybe<String>;␊
      title_ends_with?: Maybe<String>;␊
      title_not_ends_with?: Maybe<String>;␊
      text?: Maybe<String>;␊
      text_not?: Maybe<String>;␊
      text_in?: Maybe<String[] | String>;␊
      text_not_in?: Maybe<String[] | String>;␊
      text_lt?: Maybe<String>;␊
      text_lte?: Maybe<String>;␊
      text_gt?: Maybe<String>;␊
      text_gte?: Maybe<String>;␊
      text_contains?: Maybe<String>;␊
      text_not_contains?: Maybe<String>;␊
      text_starts_with?: Maybe<String>;␊
      text_not_starts_with?: Maybe<String>;␊
      text_ends_with?: Maybe<String>;␊
      text_not_ends_with?: Maybe<String>;␊
      AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;␊
      OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;␊
      NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;␊
    }␊
    ␊
    export interface PostSubscriptionWhereInput {␊
      mutation_in?: Maybe<MutationType[] | MutationType>;␊
      updatedFields_contains?: Maybe<String>;␊
      updatedFields_contains_every?: Maybe<String[] | String>;␊
      updatedFields_contains_some?: Maybe<String[] | String>;␊
      node?: Maybe<PostWhereInput>;␊
      AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;␊
      OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;␊
      NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;␊
    }␊
    ␊
    export interface PostUpdateWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput;␊
      data: PostUpdateWithoutAuthorDataInput;␊
    }␊
    ␊
    export interface PostUpsertWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput;␊
      update: PostUpdateWithoutAuthorDataInput;␊
      create: PostCreateWithoutAuthorInput;␊
    }␊
    ␊
    export interface NodeNode {␊
      id: ID_Output;␊
    }␊
    ␊
    export interface UserPreviousValues {␊
      id: ID_Output;␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserPreviousValuesPromise␊
      extends Promise<UserPreviousValues>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
    }␊
    ␊
    export interface UserPreviousValuesSubscription␊
      extends Promise<AsyncIterator<UserPreviousValues>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      email: () => Promise<AsyncIterator<String>>;␊
      password: () => Promise<AsyncIterator<String>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface PageInfo {␊
      hasNextPage: Boolean;␊
      hasPreviousPage: Boolean;␊
      startCursor?: String;␊
      endCursor?: String;␊
    }␊
    ␊
    export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {␊
      hasNextPage: () => Promise<Boolean>;␊
      hasPreviousPage: () => Promise<Boolean>;␊
      startCursor: () => Promise<String>;␊
      endCursor: () => Promise<String>;␊
    }␊
    ␊
    export interface PageInfoSubscription␊
      extends Promise<AsyncIterator<PageInfo>>,␊
        Fragmentable {␊
      hasNextPage: () => Promise<AsyncIterator<Boolean>>;␊
      hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;␊
      startCursor: () => Promise<AsyncIterator<String>>;␊
      endCursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface User {␊
      id: ID_Output;␊
      email: String;␊
      password: String;␊
      name: String;␊
    }␊
    ␊
    export interface UserPromise extends Promise<User>, Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
      posts: <T = FragmentableArray<Post>>(args?: {␊
        where?: PostWhereInput;␊
        orderBy?: PostOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => T;␊
    }␊
    ␊
    export interface UserSubscription␊
      extends Promise<AsyncIterator<User>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      email: () => Promise<AsyncIterator<String>>;␊
      password: () => Promise<AsyncIterator<String>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
      posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {␊
        where?: PostWhereInput;␊
        orderBy?: PostOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => T;␊
    }␊
    ␊
    export interface UserNullablePromise␊
      extends Promise<User | null>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      email: () => Promise<String>;␊
      password: () => Promise<String>;␊
      name: () => Promise<String>;␊
      posts: <T = FragmentableArray<Post>>(args?: {␊
        where?: PostWhereInput;␊
        orderBy?: PostOrderByInput;␊
        skip?: Int;␊
        after?: String;␊
        before?: String;␊
        first?: Int;␊
        last?: Int;␊
      }) => T;␊
    }␊
    ␊
    export interface PostEdge {␊
      node: Post;␊
      cursor: String;␊
    }␊
    ␊
    export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {␊
      node: <T = PostPromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    export interface PostEdgeSubscription␊
      extends Promise<AsyncIterator<PostEdge>>,␊
        Fragmentable {␊
      node: <T = PostSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface PostSubscriptionPayload {␊
      mutation: MutationType;␊
      node: Post;␊
      updatedFields: String[];␊
      previousValues: PostPreviousValues;␊
    }␊
    ␊
    export interface PostSubscriptionPayloadPromise␊
      extends Promise<PostSubscriptionPayload>,␊
        Fragmentable {␊
      mutation: () => Promise<MutationType>;␊
      node: <T = PostPromise>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T = PostPreviousValuesPromise>() => T;␊
    }␊
    ␊
    export interface PostSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<PostSubscriptionPayload>>,␊
        Fragmentable {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T = PostSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T = PostPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    export interface PostConnection {␊
      pageInfo: PageInfo;␊
      edges: PostEdge[];␊
    }␊
    ␊
    export interface PostConnectionPromise␊
      extends Promise<PostConnection>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoPromise>() => T;␊
      edges: <T = FragmentableArray<PostEdge>>() => T;␊
      aggregate: <T = AggregatePostPromise>() => T;␊
    }␊
    ␊
    export interface PostConnectionSubscription␊
      extends Promise<AsyncIterator<PostConnection>>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoSubscription>() => T;␊
      edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;␊
      aggregate: <T = AggregatePostSubscription>() => T;␊
    }␊
    ␊
    export interface Post {␊
      id: ID_Output;␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostPromise extends Promise<Post>, Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
      author: <T = UserPromise>() => T;␊
    }␊
    ␊
    export interface PostSubscription␊
      extends Promise<AsyncIterator<Post>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      isPublished: () => Promise<AsyncIterator<Boolean>>;␊
      title: () => Promise<AsyncIterator<String>>;␊
      text: () => Promise<AsyncIterator<String>>;␊
      author: <T = UserSubscription>() => T;␊
    }␊
    ␊
    export interface PostNullablePromise␊
      extends Promise<Post | null>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
      author: <T = UserPromise>() => T;␊
    }␊
    ␊
    export interface PostPreviousValues {␊
      id: ID_Output;␊
      isPublished: Boolean;␊
      title: String;␊
      text: String;␊
    }␊
    ␊
    export interface PostPreviousValuesPromise␊
      extends Promise<PostPreviousValues>,␊
        Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      isPublished: () => Promise<Boolean>;␊
      title: () => Promise<String>;␊
      text: () => Promise<String>;␊
    }␊
    ␊
    export interface PostPreviousValuesSubscription␊
      extends Promise<AsyncIterator<PostPreviousValues>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      isPublished: () => Promise<AsyncIterator<Boolean>>;␊
      title: () => Promise<AsyncIterator<String>>;␊
      text: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface AggregateUser {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregateUserPromise␊
      extends Promise<AggregateUser>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregateUserSubscription␊
      extends Promise<AsyncIterator<AggregateUser>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface BatchPayload {␊
      count: Long;␊
    }␊
    ␊
    export interface BatchPayloadPromise␊
      extends Promise<BatchPayload>,␊
        Fragmentable {␊
      count: () => Promise<Long>;␊
    }␊
    ␊
    export interface BatchPayloadSubscription␊
      extends Promise<AsyncIterator<BatchPayload>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Long>>;␊
    }␊
    ␊
    export interface UserEdge {␊
      node: User;␊
      cursor: String;␊
    }␊
    ␊
    export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {␊
      node: <T = UserPromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    export interface UserEdgeSubscription␊
      extends Promise<AsyncIterator<UserEdge>>,␊
        Fragmentable {␊
      node: <T = UserSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface AggregatePost {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregatePostPromise␊
      extends Promise<AggregatePost>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregatePostSubscription␊
      extends Promise<AsyncIterator<AggregatePost>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface UserSubscriptionPayload {␊
      mutation: MutationType;␊
      node: User;␊
      updatedFields: String[];␊
      previousValues: UserPreviousValues;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadPromise␊
      extends Promise<UserSubscriptionPayload>,␊
        Fragmentable {␊
      mutation: () => Promise<MutationType>;␊
      node: <T = UserPromise>() => T;␊
      updatedFields: () => Promise<String[]>;␊
      previousValues: <T = UserPreviousValuesPromise>() => T;␊
    }␊
    ␊
    export interface UserSubscriptionPayloadSubscription␊
      extends Promise<AsyncIterator<UserSubscriptionPayload>>,␊
        Fragmentable {␊
      mutation: () => Promise<AsyncIterator<MutationType>>;␊
      node: <T = UserSubscription>() => T;␊
      updatedFields: () => Promise<AsyncIterator<String[]>>;␊
      previousValues: <T = UserPreviousValuesSubscription>() => T;␊
    }␊
    ␊
    export interface UserConnection {␊
      pageInfo: PageInfo;␊
      edges: UserEdge[];␊
    }␊
    ␊
    export interface UserConnectionPromise␊
      extends Promise<UserConnection>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoPromise>() => T;␊
      edges: <T = FragmentableArray<UserEdge>>() => T;␊
      aggregate: <T = AggregateUserPromise>() => T;␊
    }␊
    ␊
    export interface UserConnectionSubscription␊
      extends Promise<AsyncIterator<UserConnection>>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoSubscription>() => T;␊
      edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;␊
      aggregate: <T = AggregateUserSubscription>() => T;␊
    }␊
    ␊
    export type Long = string;␊
    ␊
    /*␊
    The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.␊
    */␊
    export type ID_Input = string | number;␊
    export type ID_Output = string;␊
    ␊
    /*␊
    The `Boolean` scalar type represents `true` or `false`.␊
    */␊
    export type Boolean = boolean;␊
    ␊
    /*␊
    The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.␊
    */␊
    export type String = string;␊
    ␊
    /*␊
    The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. ␊
    */␊
    export type Int = number;␊
    ␊
    /**␊
     * Model Metadata␊
     */␊
    ␊
    export const models: Model[] = [␊
      {␊
        name: "Post",␊
        embedded: false␊
      },␊
      {␊
        name: "User",␊
        embedded: false␊
      }␊
    ];␊
    ␊
    /**␊
     * Type Defs␊
     */␊
    ␊
    export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({␊
      typeDefs,␊
      models␊
    });␊
    export const prisma = new Prisma();␊
    `

## typescript generator definitions

> Snapshot 1

    `// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.␊
      // Please don't change this file manually but run `prisma generate` to update it.␊
      // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/␊
    ␊
    export const typeDefs = /* GraphQL */ `type AggregatePost {␊
      count: Int!␊
    }␊
    ␊
    type AggregateUser {␊
      count: Int!␊
    }␊
    ␊
    type BatchPayload {␊
      count: Long!␊
    }␊
    ␊
    scalar Long␊
    ␊
    type Mutation {␊
      createPost(data: PostCreateInput!): Post!␊
      updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post␊
      updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!␊
      upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!␊
      deletePost(where: PostWhereUniqueInput!): Post␊
      deleteManyPosts(where: PostWhereInput): BatchPayload!␊
      createUser(data: UserCreateInput!): User!␊
      updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User␊
      updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!␊
      upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!␊
      deleteUser(where: UserWhereUniqueInput!): User␊
      deleteManyUsers(where: UserWhereInput): BatchPayload!␊
    }␊
    ␊
    enum MutationType {␊
      CREATED␊
      UPDATED␊
      DELETED␊
    }␊
    ␊
    interface Node {␊
      id: ID!␊
    }␊
    ␊
    type PageInfo {␊
      hasNextPage: Boolean!␊
      hasPreviousPage: Boolean!␊
      startCursor: String␊
      endCursor: String␊
    }␊
    ␊
    type Post {␊
      id: ID!␊
      isPublished: Boolean!␊
      title: String!␊
      text: String!␊
      author: User!␊
    }␊
    ␊
    type PostConnection {␊
      pageInfo: PageInfo!␊
      edges: [PostEdge]!␊
      aggregate: AggregatePost!␊
    }␊
    ␊
    input PostCreateInput {␊
      isPublished: Boolean!␊
      title: String!␊
      text: String!␊
      author: UserCreateOneWithoutPostsInput!␊
    }␊
    ␊
    input PostCreateManyWithoutAuthorInput {␊
      create: [PostCreateWithoutAuthorInput!]␊
      connect: [PostWhereUniqueInput!]␊
    }␊
    ␊
    input PostCreateWithoutAuthorInput {␊
      isPublished: Boolean!␊
      title: String!␊
      text: String!␊
    }␊
    ␊
    type PostEdge {␊
      node: Post!␊
      cursor: String!␊
    }␊
    ␊
    enum PostOrderByInput {␊
      id_ASC␊
      id_DESC␊
      isPublished_ASC␊
      isPublished_DESC␊
      title_ASC␊
      title_DESC␊
      text_ASC␊
      text_DESC␊
    }␊
    ␊
    type PostPreviousValues {␊
      id: ID!␊
      isPublished: Boolean!␊
      title: String!␊
      text: String!␊
    }␊
    ␊
    input PostScalarWhereInput {␊
      id: ID␊
      id_not: ID␊
      id_in: [ID!]␊
      id_not_in: [ID!]␊
      id_lt: ID␊
      id_lte: ID␊
      id_gt: ID␊
      id_gte: ID␊
      id_contains: ID␊
      id_not_contains: ID␊
      id_starts_with: ID␊
      id_not_starts_with: ID␊
      id_ends_with: ID␊
      id_not_ends_with: ID␊
      isPublished: Boolean␊
      isPublished_not: Boolean␊
      title: String␊
      title_not: String␊
      title_in: [String!]␊
      title_not_in: [String!]␊
      title_lt: String␊
      title_lte: String␊
      title_gt: String␊
      title_gte: String␊
      title_contains: String␊
      title_not_contains: String␊
      title_starts_with: String␊
      title_not_starts_with: String␊
      title_ends_with: String␊
      title_not_ends_with: String␊
      text: String␊
      text_not: String␊
      text_in: [String!]␊
      text_not_in: [String!]␊
      text_lt: String␊
      text_lte: String␊
      text_gt: String␊
      text_gte: String␊
      text_contains: String␊
      text_not_contains: String␊
      text_starts_with: String␊
      text_not_starts_with: String␊
      text_ends_with: String␊
      text_not_ends_with: String␊
      AND: [PostScalarWhereInput!]␊
      OR: [PostScalarWhereInput!]␊
      NOT: [PostScalarWhereInput!]␊
    }␊
    ␊
    type PostSubscriptionPayload {␊
      mutation: MutationType!␊
      node: Post␊
      updatedFields: [String!]␊
      previousValues: PostPreviousValues␊
    }␊
    ␊
    input PostSubscriptionWhereInput {␊
      mutation_in: [MutationType!]␊
      updatedFields_contains: String␊
      updatedFields_contains_every: [String!]␊
      updatedFields_contains_some: [String!]␊
      node: PostWhereInput␊
      AND: [PostSubscriptionWhereInput!]␊
      OR: [PostSubscriptionWhereInput!]␊
      NOT: [PostSubscriptionWhereInput!]␊
    }␊
    ␊
    input PostUpdateInput {␊
      isPublished: Boolean␊
      title: String␊
      text: String␊
      author: UserUpdateOneRequiredWithoutPostsInput␊
    }␊
    ␊
    input PostUpdateManyDataInput {␊
      isPublished: Boolean␊
      title: String␊
      text: String␊
    }␊
    ␊
    input PostUpdateManyMutationInput {␊
      isPublished: Boolean␊
      title: String␊
      text: String␊
    }␊
    ␊
    input PostUpdateManyWithoutAuthorInput {␊
      create: [PostCreateWithoutAuthorInput!]␊
      delete: [PostWhereUniqueInput!]␊
      connect: [PostWhereUniqueInput!]␊
      set: [PostWhereUniqueInput!]␊
      disconnect: [PostWhereUniqueInput!]␊
      update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]␊
      upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]␊
      deleteMany: [PostScalarWhereInput!]␊
      updateMany: [PostUpdateManyWithWhereNestedInput!]␊
    }␊
    ␊
    input PostUpdateManyWithWhereNestedInput {␊
      where: PostScalarWhereInput!␊
      data: PostUpdateManyDataInput!␊
    }␊
    ␊
    input PostUpdateWithoutAuthorDataInput {␊
      isPublished: Boolean␊
      title: String␊
      text: String␊
    }␊
    ␊
    input PostUpdateWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput!␊
      data: PostUpdateWithoutAuthorDataInput!␊
    }␊
    ␊
    input PostUpsertWithWhereUniqueWithoutAuthorInput {␊
      where: PostWhereUniqueInput!␊
      update: PostUpdateWithoutAuthorDataInput!␊
      create: PostCreateWithoutAuthorInput!␊
    }␊
    ␊
    input PostWhereInput {␊
      id: ID␊
      id_not: ID␊
      id_in: [ID!]␊
      id_not_in: [ID!]␊
      id_lt: ID␊
      id_lte: ID␊
      id_gt: ID␊
      id_gte: ID␊
      id_contains: ID␊
      id_not_contains: ID␊
      id_starts_with: ID␊
      id_not_starts_with: ID␊
      id_ends_with: ID␊
      id_not_ends_with: ID␊
      isPublished: Boolean␊
      isPublished_not: Boolean␊
      title: String␊
      title_not: String␊
      title_in: [String!]␊
      title_not_in: [String!]␊
      title_lt: String␊
      title_lte: String␊
      title_gt: String␊
      title_gte: String␊
      title_contains: String␊
      title_not_contains: String␊
      title_starts_with: String␊
      title_not_starts_with: String␊
      title_ends_with: String␊
      title_not_ends_with: String␊
      text: String␊
      text_not: String␊
      text_in: [String!]␊
      text_not_in: [String!]␊
      text_lt: String␊
      text_lte: String␊
      text_gt: String␊
      text_gte: String␊
      text_contains: String␊
      text_not_contains: String␊
      text_starts_with: String␊
      text_not_starts_with: String␊
      text_ends_with: String␊
      text_not_ends_with: String␊
      author: UserWhereInput␊
      AND: [PostWhereInput!]␊
      OR: [PostWhereInput!]␊
      NOT: [PostWhereInput!]␊
    }␊
    ␊
    input PostWhereUniqueInput {␊
      id: ID␊
    }␊
    ␊
    type Query {␊
      post(where: PostWhereUniqueInput!): Post␊
      posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!␊
      postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!␊
      user(where: UserWhereUniqueInput!): User␊
      users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!␊
      usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!␊
      node(id: ID!): Node␊
    }␊
    ␊
    type Subscription {␊
      post(where: PostSubscriptionWhereInput): PostSubscriptionPayload␊
      user(where: UserSubscriptionWhereInput): UserSubscriptionPayload␊
    }␊
    ␊
    type User {␊
      id: ID!␊
      email: String!␊
      password: String!␊
      name: String!␊
      posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]␊
    }␊
    ␊
    type UserConnection {␊
      pageInfo: PageInfo!␊
      edges: [UserEdge]!␊
      aggregate: AggregateUser!␊
    }␊
    ␊
    input UserCreateInput {␊
      email: String!␊
      password: String!␊
      name: String!␊
      posts: PostCreateManyWithoutAuthorInput␊
    }␊
    ␊
    input UserCreateOneWithoutPostsInput {␊
      create: UserCreateWithoutPostsInput␊
      connect: UserWhereUniqueInput␊
    }␊
    ␊
    input UserCreateWithoutPostsInput {␊
      email: String!␊
      password: String!␊
      name: String!␊
    }␊
    ␊
    type UserEdge {␊
      node: User!␊
      cursor: String!␊
    }␊
    ␊
    enum UserOrderByInput {␊
      id_ASC␊
      id_DESC␊
      email_ASC␊
      email_DESC␊
      password_ASC␊
      password_DESC␊
      name_ASC␊
      name_DESC␊
    }␊
    ␊
    type UserPreviousValues {␊
      id: ID!␊
      email: String!␊
      password: String!␊
      name: String!␊
    }␊
    ␊
    type UserSubscriptionPayload {␊
      mutation: MutationType!␊
      node: User␊
      updatedFields: [String!]␊
      previousValues: UserPreviousValues␊
    }␊
    ␊
    input UserSubscriptionWhereInput {␊
      mutation_in: [MutationType!]␊
      updatedFields_contains: String␊
      updatedFields_contains_every: [String!]␊
      updatedFields_contains_some: [String!]␊
      node: UserWhereInput␊
      AND: [UserSubscriptionWhereInput!]␊
      OR: [UserSubscriptionWhereInput!]␊
      NOT: [UserSubscriptionWhereInput!]␊
    }␊
    ␊
    input UserUpdateInput {␊
      email: String␊
      password: String␊
      name: String␊
      posts: PostUpdateManyWithoutAuthorInput␊
    }␊
    ␊
    input UserUpdateManyMutationInput {␊
      email: String␊
      password: String␊
      name: String␊
    }␊
    ␊
    input UserUpdateOneRequiredWithoutPostsInput {␊
      create: UserCreateWithoutPostsInput␊
      update: UserUpdateWithoutPostsDataInput␊
      upsert: UserUpsertWithoutPostsInput␊
      connect: UserWhereUniqueInput␊
    }␊
    ␊
    input UserUpdateWithoutPostsDataInput {␊
      email: String␊
      password: String␊
      name: String␊
    }␊
    ␊
    input UserUpsertWithoutPostsInput {␊
      update: UserUpdateWithoutPostsDataInput!␊
      create: UserCreateWithoutPostsInput!␊
    }␊
    ␊
    input UserWhereInput {␊
      id: ID␊
      id_not: ID␊
      id_in: [ID!]␊
      id_not_in: [ID!]␊
      id_lt: ID␊
      id_lte: ID␊
      id_gt: ID␊
      id_gte: ID␊
      id_contains: ID␊
      id_not_contains: ID␊
      id_starts_with: ID␊
      id_not_starts_with: ID␊
      id_ends_with: ID␊
      id_not_ends_with: ID␊
      email: String␊
      email_not: String␊
      email_in: [String!]␊
      email_not_in: [String!]␊
      email_lt: String␊
      email_lte: String␊
      email_gt: String␊
      email_gte: String␊
      email_contains: String␊
      email_not_contains: String␊
      email_starts_with: String␊
      email_not_starts_with: String␊
      email_ends_with: String␊
      email_not_ends_with: String␊
      password: String␊
      password_not: String␊
      password_in: [String!]␊
      password_not_in: [String!]␊
      password_lt: String␊
      password_lte: String␊
      password_gt: String␊
      password_gte: String␊
      password_contains: String␊
      password_not_contains: String␊
      password_starts_with: String␊
      password_not_starts_with: String␊
      password_ends_with: String␊
      password_not_ends_with: String␊
      name: String␊
      name_not: String␊
      name_in: [String!]␊
      name_not_in: [String!]␊
      name_lt: String␊
      name_lte: String␊
      name_gt: String␊
      name_gte: String␊
      name_contains: String␊
      name_not_contains: String␊
      name_starts_with: String␊
      name_not_starts_with: String␊
      name_ends_with: String␊
      name_not_ends_with: String␊
      posts_every: PostWhereInput␊
      posts_some: PostWhereInput␊
      posts_none: PostWhereInput␊
      AND: [UserWhereInput!]␊
      OR: [UserWhereInput!]␊
      NOT: [UserWhereInput!]␊
    }␊
    ␊
    input UserWhereUniqueInput {␊
      id: ID␊
    }␊
    ``
